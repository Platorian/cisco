This section covers enumeration techniques that should be performed in the information-gathering phase of a penetration test. You will learn how and when these enumeration techniques should be used. This section also includes examples of performing these types of enumeration by using Nmap as well as a deep dive into packet crafting with Scapy.

- Host Enumeration
- User Enumeration
- Group Enumeration
- Network Share Enumeration
- Additional SMB Enumeration Examples
- Web Page Enumeration/Web Application Enumeration
- Service Enumeration
- Exploring Enumeration via Packet Crafting

---

**Host Enumeration**

The enumeration of hosts is one of the first tasks you need to perform in the information-gathering phase of a penetration test. **_Host enumeration_** is performed internally and externally. When performed externally, you typically want to limit the IP addresses you are scanning to just the ones that are part of the scope of the test. This reduces the chance of inadvertently scanning an IP address that you are not authorized to test. When performing an internal host enumeration, you typically scan the full subnet or subnets of IP addresses being used by the target. Host enumeration is usually performed using a tool such as Nmap or Masscan; however, vulnerability scanners also perform this task as part of their automated testing. Example 3-23, earlier in this module, shows a sample Nmap ping scan being used for host enumeration on the network 192.168.88.0/24. In earlier versions of Nmap, the Nmap ping scan option was **-sP** (not **-sn** ).

---

**User Enumeration**

Gathering a valid list of users is the first step in cracking a set of credentials. When you have the username, you can then begin brute-force attempts to get the account password. You perform **_user enumeration_** when you have gained access to the internal network. On a Windows network, you can do this by manipulating the Server Message Block (SMB) protocol, which uses TCP port 445. Figure 3-12 illustrates how a typical SMB implementation works.

**_Figure 3-12_** _- SMB Message Illustration_

![[Pasted image 20240621094347.png]]

The information contained in the responses to these messages enables you to reveal information about the server:

- **SMB_COM_NEGOTIATE:** This message allows the client to tell the server what protocols, flags, and options it would like to use. The response from the server is also an SMB_COM_NEGOTIATE message. This response is relayed to the client about which protocols, flags, and options it prefers. This information can be configured on the server itself. A misconfiguration sometimes reveals information that you can use in penetration testing. For instance, the server might be configured to allow messages without signatures. You can determine if the server is using share- or user-level authentication mechanisms and whether the server allows plaintext passwords. The response from the server also provides additional information, such as the time and time zone the server is using. This is necessary information for many penetration testing tasks.
- **SMB_COM_SESSION_SETUP_ANDX** : After the client and server have negotiated the protocols, flags, and options they will use for communication, the authentication process begins. Authentication is the primary function of the SMB_COM_SESSION_SETUP_ANDX message. The information sent in this message includes the client username, password, and domain. If this information is not encrypted, it is easy to sniff it right off the network. Even if it is encrypted, if the mechanism being used is not sufficient, the information can be revealed using tools such as Lanman and NTLM in the case of Microsoft Windows implementations. The following example shows this message being used with the smb-enum-users.nse script:
    
    `nmap --script smb-enum-users.nse <host>`
    

Example 3-24 shows the results of the Nmap **smb-enum-users** script run against the target 192.168.88.251. As you can see, the results indicate that the script was able to enumerate the users who are configured on this Windows target. The highlighted line reveals the user who was enumerated by Nmap (derek).

**_Example 3-24_** _-_ _Enumerating SMB Users_

![[Pasted image 20240621094444.png]]

---

**Group Enumeration**

For a penetration tester, **_group enumeration_** is helpful in determining the authorization roles that are being used in the target environment. The Nmap NSE script for enumerating SMB groups is **smb-enum-groups**. This script attempts to pull a list of groups from a remote Windows machine. You can also reveal the list of users who are members of those groups. The syntax of the command is as follows:

`nmap --script smb-enum-groups.nse -p445 <host>`

Example 3-25 shows sample output of this command run against the Windows server at 192.168.56.3. This example uses known credentials to gather information.

**_Example 3-25_** _-_ _Enumerating SMB Groups_

![[Pasted image 20240621094546.png]]

The highlighted output in Example 3-25 shows the enumerated groups and users in the target host. In Windows, the relative identifier (RID) is a variable-length number assigned to objects and becomes part of the object’s security identifier (SID) that uniquely identifies an account or a group within a domain. To learn more about the different RID numbers, see _[https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows](https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows)_.

---

**Network Share Enumeration**

Identifying systems on a network that are sharing files, folders, and printers is helpful in building out an attack surface of an internal network. The Nmap **smb-enum-shares** NSE script uses Microsoft Remote Procedure Call (MSRPC) for **_network share enumeration_**. The syntax of the Nmap **smb-enum-shares.nse** script is as follows:

`nmap --script smb-enum-shares.nse -p 445 <host>`

Example 3-26 demonstrates the enumeration of SMB shares.

**_Example 3-26_** _-_ _Enumerating SMB Shares_

![[Pasted image 20240621094647.png]]
![[Pasted image 20240621094706.png]]

---

**Additional SMB Enumeration Examples**

The system used in earlier examples (with the IP address 192.168.88.251) is running Linux and Samba. However, it is not easy to determine that it is a Linux system from the results of previous scans. An easy way to perform additional enumeration and fingerprinting of the applications and operating system running on a host is by using the **nmap -sC** command. The - **sC** option runs the most common NSE scripts based on the ports found to be open on the target system.

**NOTE** You can locate the installed NSE scripts in Kali Linux and Parrot OS by simply using the **locate *.nse** command. The site _[https://nmap.org/book/man-nse.html](https://nmap.org/book/man-nse.html)_ includes a detailed explanation of the NSE and how to create new scripts using the Lua programming language.

Example 3-27 shows the output of the **nmap -sC** command launched against the Linux system at 192.168.88.251, which is running Samba.

**_Example 3-27_** _-_ _Running the Nmap NSE Default Scripts_

```
nmap -sC 192.168.88.251
```

![[Pasted image 20240621094807.png]]

The highlighted lines in Example 3-27 show details about the Samba version that is running on the system (Samba Version 4.9.5). You can also see that even though the OS is marked as Windows 6.1, the correct operating system is Debian. Example 3-28 shows the output of the **samba -V** command at the target system (vulnhost-1), which confirms that the scanner was able to determine the correct Samba version.

**_Example 3-28_** _-_ _Confirming Scan Results in the Target System_

![[Pasted image 20240621094822.png]]

You can also use tools such as enum4linux to enumerate Samba shares, including user accounts, shares, and other configurations. Example 3-29 shows the output of the enum4linux tool after it is launched against the target system (192.168.88.251).

**_Example 3-29_** _-_ _Enumerating Additional Information Using enum4linux_

```
enum4linux 192.168.88.251
```

![[Pasted image 20240621094905.png]]

![[Pasted image 20240621094915.png]]

There is a Python-based enum4linux implementation called enum4linux-ng that can be downloaded from _[https://github.com/cddmp/enum4linux-ng](https://github.com/cddmp/enum4linux-ng)_.

Example 3-30 shows an example of SMB enumeration using enum4linux-ng.

**_Example 3-30_** _-_ _Enumeration Using enum4linux-ng_

```
./enum4linux-ng.py -As 192.168.88.251
```

![[Pasted image 20240621094950.png]]

![[Pasted image 20240621095003.png]]

The highlighted lines in Example 3-30 show the enumerated users, Samba version, and shared folders. You can also use simple tools such as smbclient to enumerate shares and other information from a system running SMB, as demonstrated in Example 3-31.

**_Example 3-31_** _-_ _Enumeration Using smbclient_

![[Pasted image 20240621095019.png]]

---

**Web Page Enumeration/Web Application Enumeration**

Once you have identified that a web server is running on a target host, the next step is to take a look at the web application and begin to map out the attack surface performing **_web page enumeration_** or often referred to as **_web application enumeration_**. You can map out the attack surface of a web application in a few different ways. The handy Nmap tool actually has an NSE script available for brute forcing the directory and file paths of web applications. Armed with a list of known files and directories used by common web applications, it probes the server for each of the items on the list. Based on the response from the server, it can determine whether those paths exist. This is handy for identifying things like the Apache or Tomcat default manager page that are commonly left on web servers and can be potential paths for exploitation. The syntax of the http-enum NSE script is as follows:

`nmap -sV --script=http-enum <target>`

Example 3-32 displays the results of running this script against the host with the IP address 192.168.88.251.

**_Example 3-32_** _-_ _Sample Nmap http-enum Script Output_

![[Pasted image 20240621095102.png]]

The highlighted output in Example 3-32 shows several enumerated directories/folders and the version of the web server being used (Nginx 1.17.2). This is a good place to start in attacking a web application.

Another web server enumeration tool we should talk about is Nikto. Nikto is an open-source web vulnerability scanner that has been around for many years. It’s not as robust as the commercial web vulnerability scanners; however, it is very handy for running a quick script to enumerate information about a web server and the applications it is hosting. Because of the speed at which Nikto works to scan a web server, it is very noisy. It provides a number of options for scanning, including the capability to authenticate to a web application that requires a username and password. Example 3-33 shows the output of a Nikto scan being run against the same host as in Example 3-32 (192.168.88.251). The output in Example 3-33 shows similar results to the Nmap script used in Example 3-32.

**_Example 3-33_** _-_ _Sample Nikto Scan_

```
nikto -h 192.168.88.251
```

![[Pasted image 20240621095141.png]]

**TIP** No tool is perfect. It is recommended that you become familiar with the behavior and output of different tools. Module10 covers several additional tools that can be used for enumeration and reconnaissance.

---

**Service Enumeration**

**_Service enumeration_** is the process of identifying the services running on a remote system, and it is a primary focus of what Nmap does as a port scanner. Earlier discussion in this module highlights the various scan types and how they can be used to bypass filters. When you are connected to a system that is on a directly connected network segment, you can run some additional scripts to enumerate further. A port scan takes the perspective of a credentialed remote user. The Nmap **smb-enum-processes** NSE script enumerates services on a Windows system, and it does so by using credentials of a user who has access to read the status of services that are running. This is a handy tool for remotely querying a Windows system to determine the exact list of services running. The syntax of the command is as follows:

`nmap --script smb-enum-processes.nse --script-args smbusername=<username>, smbpass=<password> -p445 <host>`

---

**Exploring Enumeration via Packet Crafting**

When it comes to enumeration via packet crafting and generation, Scapy is one of pentesters' favorite tools and frameworks. Scapy is a very comprehensive Python-based framework or ecosystem for packet generation. This section looks at some of the simple ways you can use this tool to perform basic network reconnaissance.

**NOTE** Scapy must be run with root permissions to be able to modify packets.

Launching the Scapy interactive shell is as easy as typing **sudo scapy** from a terminal window, as illustrated in Figure 3-13.

**_Figure 3-13_** _- Starting_ **_scapy_** _from the Command Line_

![[Pasted image 20240621095310.png]]

Example 3-34 shows how easy it is to begin crafting packets. In this example, a simple ICMP packet is crafted with **malicious_payload** as the payload being sent to the destination host 192.168.88.251.

**_Example 3-34_** _-_ _Crafting a Simple ICMP Packet Using Scapy_

```
>>> send(IP(dst="192.168.88.251")/ICMP()/"malicious_payload")
.
Sent 1 packets.
```

Example 3-35 shows the ICMP packet received by the target system (192.168.88.225/vulnhost-1). The tshark packet capture tool is used to capture the crafted ICMP packet.

**_Example 3-35_** _-_ _Collecting a Crafted Packet by Using tshark_

```
sudo tshark host 192.168.78.142
```

![[Pasted image 20240621095438.png]]

Scapy supports a large number of protocols. You can use the **ls()** function to list all available formats and protocols, as demonstrated in Example 3-36.

**_Example 3-36_** _-_ _The Scapy_ **_ls()_** _Function_

![[Pasted image 20240621095459.png]]

You can use the **ls()** function to display all the options and fields of a specific protocol or packet format supported by Scapy, as shown in Example 3-37. This example shows the available fields for the TCP protocol.

**_Example 3-37_** _-_ _Listing the TCP Layer 4 Fields in Scapy_

![[Pasted image 20240621095521.png]]

Example 3-38 shows the DNS packet fields that can be modified by Scapy.

**_Example 3-38_** _-_ _Listing the Available DNS Packet Fields in Scapy_

