A web session is a sequence of HTTP request and response transactions between a web client and a server. The process includes the steps illustrated.

![[Pasted image 20240615141349.png]]

A large number of web applications keep track of information about each user for the duration of the web transactions. Several web applications have the ability to establish variables such as access rights and localization settings. These variables apply to each and every interaction a user has with the web application for the duration of the session. For example, Figure 6-16 shows Wireshark being used to collect a packet capture of a web session to cnn.com. You can see the different elements of a web request (such as **GET** ) and the response. You can also see localization information (in this case, Raleigh, NC) in a cookie.

**_Figure 6-16_** _- A Packet Capture of a Web Session_

![[Pasted image 20240615142106.png]]

As you learned earlier in this module, applications can create sessions to keep track of users before and after authentication.

Once an authenticated session has been established, the session ID (or token) is temporarily equivalent to the strongest authentication method used by the application, such as username and password, one-time password, client-based digital certificate, and so on.

**NOTE** A good resource that provides a lot of information about application authentication is the OWASP Authentication Cheat Sheet, available at [_https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html_](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html).

In order to keep the authenticated state and track users’ progress, applications provide users with a session ID, or token. This token is assigned at session creation time and is shared and exchanged by the user and the web application for the duration of the session. The session ID is a name/value pair.

There are multiple mechanisms available in HTTP to maintain session state within web applications, such as cookies (in the standard HTTP header), URL parameters and rewriting (defined in RFC 3986), and URL arguments on **GET** requests. Application developers also use body arguments on **POST** requests. For example, they can use hidden form fields (HTML forms) or proprietary HTTP headers.

One of the most widely used session ID exchange mechanisms is cookies. Cookies offer advanced capabilities that are not available in other methods. Figure 6-17 illustrates session management and the use of cookies.

**_Figure 6-17_** _- Session Cookies_

![[Pasted image 20240615142438.png]]

The session ID names used by the most common web application development frameworks can be easily fingerprinted. For example, it is possible to easily fingerprint these development frameworks and languages by using the following session ID names:

- **PHP:** PHPSESSID
- **J2EE:** JSESSIONID
- **ColdFusion:** CFID and CFTOKEN
- **ASP.NET:** ASP.NET_SessionId

**TIP** It is recommended to change the default session ID name of the web development framework to a generic name, such as **id**. The session ID must be long enough to prevent brute-force attacks. Sometimes developers set it to just a few bits, but the session ID must be at least 128 bits (16 bytes). Also, the session ID must be unique and unpredictable. It’s a good idea to use a cryptographically secure pseudorandom number generator (PRNG) because the session ID value must provide at least 256 bits of entropy.

Sometimes the session ID is included in the URL. This dangerous practice can lead to the manipulation of the ID or session fixation attacks.

Web development frameworks such as ASP.NET, PHP, and Ruby on Rails provide their own session management features and associated implementation.

**NOTE** It is recommended to use these built-in frameworks rather than build your own from scratch since they have been tested by many people. Unfortunately, when you perform pen testing, you are likely to find people trying to create their own frameworks.

This is pretty obvious, but you have to remember to encrypt an entire web session with HTTPS – not only for the authentication process where the user credentials are exchanged but also to ensure that the session ID is exchanged only through an encrypted channel. Using an encrypted communication channel also protects the session against some session fixation attacks, in which the attacker is able to intercept and manipulate the web traffic to inject (or fix) the session ID on the victim’s web browser.

There are two types of cookies: non-persistent (or session) cookies and persistent cookies. If a cookie has a **Max-Age** or **Expires** attribute, it is considered a persistent cookie and is stored on disk by the web browser until the expiration time.

Configuring a cookie with the **HTTPOnly** flag forces the web browser to have this cookie processed only by the server, and any attempt to access the cookie from client-based code or scripts is strictly forbidden. This protects against several type of attacks, including CSRF.

**TIP** Modern applications typically track users after authentication by using non-persistent cookies. This forces the session information to be deleted from the client if the current web browser instance is closed. It is important to use non-persistent cookies so the session ID does not remain in the web client cache for long periods of time. In addition, this is why it is important to validate and verify session IDs, as covered earlier in this module.

---

There are several ways an attacker can perform session hijacking and several ways a session token may be compromised:

- **Predicting session tokens:** This is why it is important to use non-predictable tokens, as previously discussed in this section.
- **Session sniffing:** This can occur through collecting packets of unencrypted web sessions.
- **On-path attack (formerly known as man-in-the-middle attack):** With this type of attack, the attacker sits in the path between the client and the web server. In addition, a browser (or an extension or a plugin) can be compromised and used to intercept and manipulate web sessions between the user and the web server. This browser-based attack was previously known as a man-in-the-browser attack.

If web applications do not validate and filter out invalid session ID values, they can potentially be used to exploit other web vulnerabilities, such as SQL injection (if the session IDs are stored on a relational database) or persistent XSS (if the session IDs are stored and reflected back afterward by the web application).

**NOTE** XSS is covered later in this module.

---
Practice

To protect against session hijacking, you should verify that the developers have:

- changed the default session ID name of the web development framework to the generic name
- ensured that the session ID is long enough to prevent brute-force attacks; the session ID must be at least 128 bits long.
- ensured that the session ID is unique and unpredictable
- used a cryptographically secure pseudorandom number generator (PRNG) for the session ID
