Application programming interfaces (APIs) are used everywhere today. A large number of modern applications use APIs to allow other systems to interact with the application. Unfortunately, many APIs lack adequate controls and are difficult to monitor. The breadth and complexity of APIs also make it difficult to automate effective security testing. There are a few methods or technologies behind modern APIs:

- **Simple Object Access Protocol (SOAP):** This standards-based web services access protocol was originally developed by Microsoft and has been used by numerous legacy applications for many years. SOAP exclusively uses XML to provide API services. XML-based specifications are governed by XML Schema Definition (XSD) documents. SOAP was originally created to replace older solutions such as the Distributed Component Object Model (DCOM) and Common Object Request Broker Architecture (CORBA). You can find the latest SOAP specifications at [_https://www.w3.org/TR/soap_](https://www.w3.org/TR/soap).
- **Representational State Transfer (REST):** This API standard is easier to use than SOAP. It uses JSON instead of XML, and it uses standards such as Swagger and the OpenAPI Specification ( [_https://www.openapis.org_](https://www.openapis.org) ) for ease of documentation and to encourage adoption.
- **GraphQL:** GraphQL is a query language for APIs that provides many developer tools. GraphQL is now used for many mobile applications and online dashboards. Many different languages support GraphQL. You can learn more about GraphQL at [_https://graphql.org/code_](https://graphql.org/code).

**NOTE** SOAP and REST use the HTTP protocol. However, SOAP is limited to a more strict set of API messaging patterns than REST. As a best practice, you should always use Hypertext Transfer Protocol Secure (HTTPS), which is the secure version of HTTP. HTTPS uses encryption over the Transport Layer Security (TLS) protocol in order to protect sensitive data.

An API often provides a roadmap that describes the underlying implementation of an application. This roadmap can give penetration testers valuable clues about attack vectors they might otherwise overlook. API documentation can provide a great level of detail that can be very valuable to a penetration tester. API documentation can include the following:

- **Swagger (OpenAPI):** Swagger is a modern framework of API documentation and development that is the basis of the OpenAPI Specification (OAS). Additional information about Swagger can be obtained at [_https://swagger.io_](https://swagger.io). The OAS specification is available at [_https://github.com/OAI/OpenAPI-Specification_](https://github.com/OAI/OpenAPI-Specification).
- **Web Services Description Language (WSDL) documents:** WSDL is an XML-based language that is used to document the functionality of a web service. The WSDL specification can be accessed at [_https://www.w3.org/TR/wsdl20-primer_](https://www.w3.org/TR/wsdl20-primer).
- **Web Application Description Language (WADL) documents:** WADL is an XML-based language for describing web applications. The WADL specification can be obtained from [_https://www.w3.org/Submission/wadl_](https://www.w3.org/Submission/wadl).

When performing pen testing against an API, it is important to collect full requests by using a proxy such as Burp Suite or OWASP ZAP. (You will learn more about these tools in Module 10.) It is important to make sure that the proxy is able to collect full API requests and not just URLs because REST, SOAP, and other API services use more than just **GET** parameters.

When you are analyzing the collected requests, look for nonstandard parameters and for abnormal HTTP headers. You should also determine whether a URL segment has a repeating pattern across other URLs. These patterns can include a number or an ID, dates, and other valuable information. Inspect the results and look for structured parameter values in JSON, XML, or even nonstandard structures.

**TIP** If you notice that a URL segment has many values, it may be because it is a parameter and not a folder or a directory on the web server. For example, if the URL **http://web.h4cker.org/s/****_abcd_****/page** repeats with different values for _abcd_ (such as **http://web.h4cker.org/s/dead/page** or **http://web.h4cker.org/s/beef/page**), those changing values are definitely API parameters.

You can also use fuzzing to find API vulnerabilities (or vulnerabilities in any application or system). According to OWASP, “Fuzz testing or Fuzzing is an unknown environment/black box software testing technique, which basically consists in finding implementation bugs using malformed/semi-malformed data injection in an automated fashion.”

**NOTE** Refer to the OWASP page [_https://www.owasp.org/index.php/Fuzzing_](https://www.owasp.org/index.php/Fuzzing) to learn about the different types of fuzzing techniques to use with protocols, applications, and other systems. In Module 10 you will see examples of fuzzers and how to use them to find vulnerabilities.

When testing APIs, you should always analyze the collected requests to optimize fuzzing. After you find potential parameters to fuzz, determine the valid and invalid values that you want to send to the application. Of course, fuzzing should focus on invalid values (for example, sending a **GET** or **PUT** with large values or special characters, Unicode, and so on). In Module 10 you will learn about tools like Radamsa ([_https://gitlab.com/akihe/radamsa_](https://gitlab.com/akihe/radamsa)) that can be used to create fuzzing parameters for testing applications, protocols, and more.

**NOTE** OWASP has a REST Security Cheat Sheet that provides numerous best practices on how to secure RESTful (REST) APIs. See [_https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html_](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html).

The following are several general best practices and recommendations for securing APIs:

- Secure API services to provide HTTPS endpoints with only a strong version of TLS.
- Validate parameters in the application and sanitize incoming data from API clients.
- Explicitly scan for common attack signatures; injection attacks often betray themselves by following common patterns.
- Use strong authentication and authorization standards.
- Use reputable and standard libraries to create the APIs.
- Segment API implementation and API security into distinct tiers; doing so frees up the API developer to focus completely on the application domain.
- Identify what data should be publicly available and what information is sensitive.
- If possible, have a security expert do the API code verification.
- Make internal API documentation mandatory.
- Avoid discussing company API development (or any other application development) on public forums.

**NOTE** CWE-227, “API Abuse,” covers unsecured APIs. For detailed information about CWE-227, see [_https://cwe.mitre.org/data/definitions/227.html_](https://cwe.mitre.org/data/definitions/227.html).

---

Practice - Unprotected APIs

Match the technologies behind modern APIs to their descriptions.

![[Pasted image 20240616114350.png]]

