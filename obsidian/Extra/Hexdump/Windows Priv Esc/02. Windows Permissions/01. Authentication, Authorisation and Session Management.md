## Authentication, Authorisation and Session Management

Anytime we interact with a secure digital system that has different permission roles, we will always have to deal with the following three aspects:

- **Authentication:** who are you?
- **Authorisation:** what can you do
- **Session Management:** how is the information regarding the identity of the user stored and processed while the user is using an authenticated session?

## Security Principals and Security Identifier (SID)

**Security principles** can represent any entity that can be authenticated by the operating system.

A security identifier is used to uniquely identify a security principle or security group.

**SID** -> Security Identifier.

Examples of security principles:
- user account
- computer account (service accounts)
- thread or process

The **SID** cannot be changed and is generated upon the user or groups creation.

**SIDs** are generated by different components depending on the situation:

- The **SID** for local accounts and groups is generated by the **Local Security Authority (LSA)**.
- The **SID** for domain users and domain groups is generated by the **Domain Controller (DC)**.

**SIDs** are used by windows to identify security principles for access control management (authorisation management).

## SID Structure

The SID is made up of different parts.

Example:
> S-R-X-Y1-Yn-1-Yn

Where:
- **S** - indicates that the string is a SID.
- **R** - indicates the **revision** of the SID structure that is used. Typically it has a value of 1.
- **X** - determines the **identifier authority** that issued the SID.
- **Y** - determines the **subauthorities**. 

All values up to, but not including, the last value in the series collectively identify a domain in an enterprise. This part of the series is called **domain identifier**.

The last value in the series, which is called the **relative identifier (RID)**, identifies a particular account or group relative to a domain.

The SID's most important information is contained in the series of subauthority values. The first part of the series (-Y1-Y2-Yn-1) is the domain identifier.

No two domains in an enterprise share the same domain identifier.

The last item in the series of subauthority  values (-Yn) is the relative identifier. It distinguishes one account or group from all other accounts and groups in the domain.

No two accounts or groups in any domain share the same relative identifier.

Consider the following SID

Example:
> S-1-5-32-544

This SID has four components:
- A revision level (1)
- An identifier authority value (5, NT Authority)
- A domain identifier (32, Builtin)
- A relative identifier (544, Administrators)

Consider another SID

Example:
> S-1-5-21-1004336348-1177238915-682003330-512

The SID for Contoso\Domain Admins has:
- A revision level (1)
- An identifier (5, NT Authority)
- A domain identifier (1-1004336348-1177238915-682003330, Contoso)
- A releavtive identifier (512, Domain Admins)

The SID for Contoso\Domain Admins is distinguished from the SIDs for other Domain Admins groups in the same enterprise by its domain identifier:

Example:
> 21-1004336348-1177238915-682003330

The SID for Contoso\Domain Admins is distinguished from the SIDs for other accounts and groups that are created in the Contoso domain by it's relative identifier

Example:
> 512

## Well Known SIDs

The value of certain SIDs are constant across all systems.

They're created when the operating system or domain is installed. They're called **well-known-SIDs** because they identify generic users or generic groups.

There are universal well-known  that are meaningful on all secure systems that use this security model, including operating systems other than Windows.

In addition, there are well-known SIDs that are meaningful only on Windows operating systems.

## Enumerating SIDs

Obtain the SID for the current logged in user
```cmd
whoami /user
```

We can enumerate the SIDs with the `wmic` command
```cmd
wmic useraccount get domain, name, sid
```

##  Access Token

Upon user authentication, an access token is generated by windows and assigned to the user. The token contains data that determines the security context of the user and is later used for performing authorisation checks.

**Access Tokens** contain the following information:
- The security identifier (**SID**) for the users account..
- SIDs for the groups of which the user is a member.
- A logon SID that identifies the current logon session. 
- A list of privileges held by the user or the user's groups.
- An owner SID.
- The SID for the primary group.
- The default discretionary access control list (**DACL**) the system uses when the user creates a securable object.
- The source of the access token.
- Whether the token is a **primary** or **impersonation** token.
- An optional list of **restricting SIDs**.
- Current impersonation levels
- Other statistics.

When a user starts a process or thread, a token will be assigned to these objects. The token is called a **primary token** and it specifies the permission of the process or thread.

Processes and threads can also have an **impersonation token** assigned. They are used to change the security context rather than the process that owns the thread .

To retrieve the primary token use the following win32 APIs:
- **OpenProcessToken()** - for processes
- **OpenThreadToken()** - for threads

## Files Permissions (icacls)

To check permissions on a given file we can use the **icacls** command as follows:

```cmd
icacls CMD.txt
```

```cmd
icacls binary.exe
```

```cmd
icacls.exe test.txt
```

The program displays ACLs, where each ACL is made up of various ACEs

**ACL** - Access Control List
**ACE** - Access Control Entry

Each ACL has the following structure:
> `<SID>:<Perm>`

Where SIDs may be in either numerical or friendly name form.

An Access Control Entry (**ACE**) is an individual permission rule which controls the individual permissions of a security principle on a file object. These are the following high-level permissions for an  **ACL**: 
- Full Access (F)
- Modify Access (M)
- Read and Execute Access (RX)
- Read-Only Access (R)
- Write-Only Access (W)

There are more advanced permissions too that deal with inheritance rights which only apply to directories.
- Object Inherit (OI)
- Container Inherit (CI)
- Inherit Only (IO)
- Do Not Propagate Inherit (NP)
- Permission Inherited from Parent Container (I)

To list out these permissions we can use **icacls** in the normal **cmd.exe** and **Get-Acl** and **Set-Acl** when using powershell. 

To grant a specific permission we proceed as follows:

```cmd
icacls test.txt /grant hostname\username:R /t /c
```

Where:
- **/t** - is used to set the permissions recursively on the entire folder.
- **/c** - tells the command to keep going.
- **:R** the right you want to grant.

## Mandatory Integrity Control (MIC)

**MIC** - Mandatory Integrity Control 

MIC provides a mechanism for controlling access to securable objects. This mechanism is in addition to discretionary access control and evaluates access before access checks against an object's discretionary access control list (DACL) are evaluated. 

When processes are started or objects are created, they receive the integrity level of the principle performing this operation.

Windows defines four integrity levels:
- System
- High
- Medium
- Low

Standard users receive medium, elevated users receive high.

When a user attempts to launch an executable file, the new process is created with the minimum of the user integrity level and the file integrity level. This means that the new process will never execute with higher integrity than the executable file.

If the administrator user executes a low integrity program, the token for the new process functions with the low integrity level. 

To understand your current integrity level you can execute **whoami /groups**

```cmd
whoami /groups
```

To change the integrity level of an object you can use the **icacls** command as follows:

```cmd
icacls test.txt /setintegritylevel high
```

## User Account Control (UAC)

**UAC** - User Account Control

UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an administrator.

After a successful authentication an administrative user obtains two access tokens:
- The first token is a standard user token (filtered admin token), which is used to perform all non-privileged operations.
- The second token is a regular administrator token. It will be used when the user wants to perform a privileged operation.

To leverage the administrator token, a UAC consent prompt needs to be confirmed.

## References

Security Identifiers (SIDs)
- https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-identifiers
- https://learn.microsoft.com/en-us/windows/win32/api/winnt/ne-winnt-well_known_sid_type

Access Tokens
- https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens

Mandatory Integrity Controls
- https://learn.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control

File Permissions (icacls.exe)
- https://superuser.com/questions/322423/explain-the-output-of-icacls-exe-line-by-line-item-by-item
- https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc753525(v=ws.10)?redirectedfrom=MSDN

 Play with Windows API and Impersonation
 - https://0x00-0x00.github.io/research/2018/10/17/Windows-API-and-Impersonation-Part1.html

















